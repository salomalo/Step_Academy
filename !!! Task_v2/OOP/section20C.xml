<?xml version="1.0" encoding="windows-1251" ?>
<?xml:stylesheet type="text/xsl" href="common/layout.xsl" ?>

<lesson title="ООП" next="courseworks.xml" prev="section19C.xml" summ="1">

<h2>20С. Домашні завдання по курсу ООП</h2>
  <h3>Урок 1. Класи. Конструктори та деструктори.</h3>
<h5>Завдання 1. Класна робота</h5>
<p>
Створити клас <b>"Точка" (Point)</b>, який складається з двох полів типу int: X та Y. Необхідно забезпечити:
<ol>
<li>Введення координат точки користувачем</li>
<li>Вивід інформації про точку на екран</li>
<li>Можливість зміни будь-якої з координат на запит користувача (X або Y)</li>
</ol>
</p>
<h5>Завдання 2. Домашнє завдання</h5>
<p>Написати клас <b>"Банківський рахунок" (Account)</b>, який містить:
<ul>
<li>Номер рахунку</li>
<li>Розмір коштів на рахунку</li>
<li>Назва валюти рахунку (рублі, гривні, евро тощо), для позначення якої можна скористатись одним символом: R, G, E, $ тощо</li>
</ul>
Забезпечити можливість:
<ol>
<li>Відкривати рахунок та первинно вносити гроші на рахунок</li>
<li>Знімати гроші з рахунку</li>
<li>Докладати гроші на рахунок</li>
</ol>
<b>ПРИМІТКА!</b> На 12 балів реалізувати також можливість здійснювати переказ грошей з одного рахунку на другий.
</p>
<hr/>
<h3>Урок 2. Конструктори з параметрами. Постійні методи класу. Об'єкти класу та функції</h3>
<p>Створити клас <b>Int</b>, що імітує роботу стандартного типу int. Наприклад, код основної програми (в функції main()) буде мати наступний вигляд:</p>
<example>
//при використанні змінних стандартного типу int
int a = 5, b = 2, res = 0;
res = a + b;
<![CDATA[cоut << res << еndl; ]]>

//при використанні обєктів типу cInt, аналогічний код буде мати викляд
cInt a(5), b(2), res;
res = a.Sum(b);
<![CDATA[cоut << res.GetValue() << еndl; ]]>
</example>
<p>Єдине поле даного класу повинно мати тип int.</p><p> Створіть методи, які будуть встановлювати значення поля рівним нулю, ініціалізувати його цілим значенням, виводити значення поля на екран та додавати два значення типу Int, а також конструктор стандартний та з параметром.</p>
<p>
Напишіть програму, в якій будуть створені три об’єкта класу Int, два з яких будуть ініціалізовані. Додайте два ініціалізованих об’єкта, присвойте результат третьому, а потім відобразіть результат на екран.</p>
<p><b>ПРИМІТКА!</b> На 12 балів реалізувати також метод, який робить дію аналогічну операції *=.</p>
<hr/>
<h3>Урок 3. Взаємодія об'єктів кількох класів. Розбивка по файлам. Класи, об'єкти та пам'ять</h3>
<h5>Завдання 1</h5>
<p>
Написати клас <b>"Карточка на знижку" (DiscountCard)</b>, який містить наступну інформацію:
<ul>
<li>Номер карточки</li>
<li>Розмір знижки (знижка передбачається накопичуваною; на початковому етапі вона рівна 1%. За кожні 1000 грн. покупки, сума знижки збільшується на 1%.)</li>
<li>Приховане допоміжне поле для збереження вартості накупленого товару</li>
<li>Дата видачі карточки, яка має тип <b>CDate</b>  (клас CDate орієнтовно містить наступні поля та методи: month, day, year, SetDate() та ShowDate() в форматі "12/02/1200")</li>
</ul>
Забезпечити можливість:
<ol>
<li>Купляти товар з використанням карточки на знижку;</li>
<li>Виводити інформацію про поточну величину знижки;</li>
<li>Виводити інформацію про те, на яку суму ще необхідно докупити товару, щоб величина знижки збільшилась.</li>
</ol>
</p>
<h5>Завдання 2</h5>
<p>Написати клас, який описує цифровий лічильник. <b>Лічильник</b> – це змінна з обмеженим діапазоном, значення якої скидається, коли воно досягає певного максимуму (наприклад, counter приймає значення в діапазоні 0..5). Необхідно забезпечити:<br/>
    -	Можливість встановлення максимального та мінімального значень.<br/>-	Збільшення лічильника на 1.<br/>
    -	Повернення поточного значення.<br/>-	Використати постійні методи там, де це необхідно.
  </p>
<p>Орієнтовний приклад реалізації програми:<br/> <img src="images/counter.gif" /></p>
<hr />
  <h3>Урок 4. Вказівники на об’єкти. Об’єкти та масиви об’єктів в області динамічної пам’яті. Масиви вказівників. Постійні в якості вказівників на методи класу. Вказівник this.</h3>
  <p>Необхідно створити клас <b>Monitor</b>, який повинен містити:<ol>
<li>поля:<ul>
<li>технічні характеристики (тип монітора (char* або enum), виробник (char*), роздільна здатність, розмір тощо);</li>
<li>ціна монітору.</li>
</ul></li>
<li>методи:<ul>
<li>Конструктор по замовчуванню та з параметрами;</li>
<li>Деструктор;</li>
<li>Стандартні методи доступу до полів класу, в яких явно використати вказівник this;</li>
<li>Методи для встановлення значень в поля класу;</li>
<li>Метод Print() для виведення полів класу на консоль.</li>
</ul></li></ol>
<b>ПРИМІТКА!</b> Змінні типу char* повинні бути динамічними, тобто зберігати свої дані в кучі. Всі необхідні методи зробити постійними, але полю з інформацією про роздільну здатність надати можливість змінювати своє значення в постійних методах класу.</p>
<p>
В основній програмі реалізувати:
<ol>
<li>Спочатку розробити <u>динамічний масив з 2 моніторів</u>, які одразу проініціалізувати даними. Вивести інформацію про всі монітори, а також підрахувати та вивести окремі ціни та загальну вартість всіх моніторів на екран.</li>
<li>Створити <u>масив вказівників на мінімум 4 об’єкти класу Monitor</u>, кожен з яких повинен створюватись різним способом: 
<ul>
<li>мінімум один з об’єктів конструктором по замовчуванню і встановлення значень полів для даного об’єкта через методи (set);</li>
<li>мінімум один об’єкт через конструктор з параметрами.</li>
</ul>
Далі, необхідно вивести інформацію про всі монітори та надати можливість пошуку монітора по заданих користувачем характеристиках.</li>
</ol></p>
<hr />
<h3>Урок 5. Вказівники на методи класу. Конструктор копій </h3>
<p>
Написати програму роботи з поїздами, на основі класу <b>Train ("Поїзд")</b>. Програма пропонує ввести з клавіатури:<ul><li>Кількість поїздів;</li>
<li>Кількість вагонів для кожного поїзда.</li></ul>На основі ведених даних створюються поїзди, виводиться загальна інформація про них та набір наступних звітів:<ol>
<li>Поїзд в якому їхала найбільша кількість пасажирів.</li>
<li>Поїзд в якому їхала найменша кількість пасажирів.</li>
</ol>
Клас <b>Train</b> повинен містити:<ol>
<li>поля:<ul>
<li>номер поїзда;</li>
<li>назва поїзда (сполучення наприклад "Львів - Київ");</li>
<li>поле "вагон" - вказівник на тип int, якому буде виділятися динамічна пам'ять розміром в кількість вагонів, де індекс даного масиву вказує на номер вагону, а значення комірки масиву на кількість пасажирів у вагоні;</li>
<li>кількість вагонів.</li>
</ul></li>
<li>методи:<ul><li>Конструктори: по замовчуванню, з параметрами та копіювання;</li>
<li>Стандартні методи доступу до полів класу;</li>
<li>Метод для виведення інформації про поїзд:<ul>
<li>Загальна кількість пасажирів.</li>
<li>Загальна кількість вагонів.</li>
<li>Номер вагону в якому їхала найменша кількість пасажирів</li>
<li>Номер вагону в якому їхала найбільша кількість пасажирів.</li>
</ul>
</li>
<li>Метод для знаходження вагона з максимальною кількість пасажирів;</li>
<li>Метод для знаходження вагона з мінімальною кількість пасажирів;</li>
<li>Метод для знаходження загальної кількості пасажирів в поїзді.</li>
</ul></li>
</ol>
</p>
   <hr/>
  <h3>Урок 6. Підсумкова практична частина по І розділу</h3>
  <p>
    Створити клас <b>Group ("Група")</b>, що містить в собі наступні поля:<br/>
    -	назва групи<br/>-	курс<br/> -	назва спеціальності (char *)<br/>-	масив студентів, що також описаний окремим класом <b>Student</b>.
  </p><p>
    Даний клас містить набір методів, що дозволяють:<br/>
    -	здійснити модифікацію окремих полів класу (назви групи, курсу та спеціальності)<br/>-	вивести інформацію про групу вцілому<br/> -	змінювати інформацію про студентів.</p>
 <hr/>
 <h3>Урок 7. Перевантаження операторів. Перевантаження арифметичних операцій та оператора присвоєння.</h3>
  <p>Створіть клас <b>XString</b>, який описує рядок. Клас повинен містити наступні конструктори:
   <ul><li>конструктор по замовчуванню, який дозволяє створити рядок довжиною 80 символів;</li>
    <li>конструктор, який створює рядок та ініціалізує його рядком, переданим в якості параметра;</li>
    <li>конструктор копій.</li></ul>
Крім того, даний клас повинен містити набір перевантажених операцій для роботи з рядками:<ul>
<li>операція *: повинна повертати новий рядок, який утворюється шляхом перетину двох рядків, тобто їх спільні символи. Наприклад, результатом перетину рядків "Microsoft" та "Windows" буде рядок "ioso".</li>
<li>операція /: повинна повертати новий рядок, який утворюється шляхом відбору символів першого рядка, яких немає в другому. Наприклад, результатом ділення рядка "Microsoft" на "Windows" буде рядок "Mcrft".</li>
<li>операцію +, що дозволяє додати два рядки (конкатенація рядків). Наприклад, результатом додавання двох рядків "Microsoft" та "Windows" буде рядок "MicrosoftWindows".</li>
<li>операцій *=, /= та +=, які діють по вищеописаному принципу.</li>
</ul></p>
<hr/>
 <h3>Урок 8. Перевантаження логічних операцій та операцій порівняння. Перевантаження оператора неявного приведення до типу</h3>
<p>Реалізувати одне завдання на ваш вибір</p>
<h5>Завдання 1 - на 9 балів</h5>
<p>Клас <b>XString («Рядок»)</b>, розроблений в уроці 7 розширити набором нижчеописаних перевантажених операторів. Щоб подивитись опис даного завдання натисніть <a href="javascript:void(0)" onClick="idTxt1.style.display='block'">тут</a>.</p>
<div id="idTxt1" style="display:none;">
<p>
<ul>
<li>Операторів порівняння: <![CDATA[  <, >, <=, >=, ==, != ]]> для можливості порівняння двох рядків</li>
<li>Оператора ! (NOT), що дозволить здійснити реверс рядка. Наприклад, результатом реверсу рядка "Windows" буде рядок "swodniW".</li>
<li>Приведення до типу char*.</li>
</ul>
В результаті пророблених дій наступний код не повинен викликати помилки:
<example>
void main()
{
	XString a = “Hello”;
	XString b = “!!!”;
	XString res = a + b;
	res.Show();		//отримаємо Hello!!!
	<![CDATA[  
	if (a == b) cout << “Equal”<<endl; 
	else cout << “Not Equal”<<endl;]]>
}
</example>
</p>
</div>
<h5>Завдання 2 - на 12 балів</h5>
  <p>Реалізувати клас <b>var («Універсальна змінна»)</b>. Щоб подивитись опис даного завдання натисніть <a href="javascript:void(0)" onClick="idTxt2.style.display='block'">тут</a>.</p>
<div id="idTxt2" style="display:none;">
<p>
Об’єкти екземпляра цього класу можуть зберігати в собі значення наступних типів: int, double, XString (рядок; клас, який був створений в уроці 7). Наприклад:
<example>
void main()
{
	var a = 15;
	var b = “Hello”;
	var c = 7.8;
	var d = “50”;
	b = a + d;
	b.Show();		//отримаємо 65
	<![CDATA[  
	if (a == b) cout << “Equal”<<endl; 
	else cout << “Not Equal”<<endl;]]>
}
</example>
</p><p>
Для класу var необхідно перевантажити:<ul><li>арифметичні оператори: +, -, *, /, +=, -=, *=, /=</li>
<li>оператори порівняння: <![CDATA[  <, >, <=, >=, ==, != ]]></li></ul>
Додати також до класу var приведення до типу: int, double, char*.</p>

<h5>Основні моменти:</h5>
<p>В змінній типу var в довільний момент часу може знаходитись лише одне значення (int або double, або ХString).</p>
<p>При перевантаженні операторів слід врахувати наступне: якщо при виконанні операції типи значень двох операндів типу var різні, тоді необхідно приводити (конвертувати) значення другого операнда до типу значення першого операнда і тільки після цього виконувати операцію. При цьому значення і тип другого операнда в самому об’єкті var не змінюється. Наприклад:
<example>
	var a = 10, b = “120”, c;
	c = a + b;
	c.Show();		//отримаємо 130
	c = b + a;
	c.Show();		//отримаємо “12010”
</example></p>
</div>
<hr/>
 <h3>Урок 9. Дружні конструкції. Перевантаження операторів направлення потоку<![CDATA[ ( >>, << ) та індексування ( [ ] ).]]></h3>
  <p>Створити клас Vector, який має два змінних-члени: сам вектор (double*) та його розмір. Даний клас має наступні методи:<br/>
    -	Стандартний конструктор;<br/>
  -	Перевантажений конструктор, який забороняє неявне приведення до типу та дозволяє задавати розмір вектора;<br/>
  -	Конструктор, що дозволяє ініціалізувати вектор іншим масивом;<br/>
  -	Конструктор копій;<br/>
  -	Деструктор;<br/>
  -	Збільшення всіх елементів вектора на 1 ( ++ ) (постфікс та префікс). Причому <u>перевантаження префіксного інкремента організувати поза межами класу</u>;<br/>
  -	Зменшення всіх елементів вектора на 1 ( -- ) (постфікс та префікс). Причому <u>перевантаження постфіксного декремента організувати поза межами класу</u>;<br/>
  -	Присвоювання вектора;<br/>
  -	Метод, що дозволяє доступатись по індексу ( [ ] );<br/>
  -	Методи додавання та віднімання двух векторів (+, -, +=, - =);<br/>
  -	Методи додавання та віднімання до/від вектора числа (+, -, +=, - =);<br/>
  -	Множення двух векторів та множення вектора на число;<br/>
  -	Введення та виведення вектора <![CDATA[(<<, >>)]]>;<br/>
  -	Метод,що повертає розмірність вектора;<br/>
  -	Методи, що дозволяють порівнювати два вектори (оператори порівняння та логічні оператори).
  </p>

  <hr/>
<h3>Урок 10. Статичні члени та методи класу. Перевантаження оператора виклику функцій ( ( ) ). Перевантаження операторів new, delete, new [], delete []</h3>
<h5>Завдання 1</h5>
<p>Доповнити створений раніше клас Vector статичною змінною-членом класу, що буде підраховувати кількість векторів, та статичним методом класу, що дозволить отримати дані з статичної змінної. Також для вектора перевантажити оператор виклику функції, що дозволить обновляти об’єкт значеннями нового масиву (дана операторна функція повинна містити два параметри – масив типу double* та його розмір).</p>
<h5>Завдання 2</h5>
<p>Створити клас для роботи з матрицями. Передбачити функції для додавання ( + ), множення двох матриць ( * ), транспонування матриць ( ! ), присвоєння матриць одна одній, встановлення та отримання довільного елемента матриці. Необхідно перевантажити відповідні оператори</p>
<hr />
<h3>Урок 11. Оператори * (розіменування), -> (доступу по вказівнику)</h3>
<p>Доробити всі заборгованості</p>
<hr/>
<h3>Урок 12. Динамічні структури даних. Стек. Проста та кільцева черга</h3>
<p>Реалізуйте одне завдання на ваш вибір</p>
<h5>Завдання 1 - на 9 балів</h5>
<p>Напишіть програму з трьома класами - автомат, обойма, куля. Кожна куля пронумерована, обойма реалізована у вигляді стеку і містить 30 куль. Автомат вміє:<ol><li>заряджати кулю в обойму</li> 
<li>стріляти - виштовхувати кулю з обойми, і влучати в мішень з долею вірогідності 70%.</li></ol>При пострілі в консоль має виводитись повідомлення такого типу:
<example>
Автомат вистрелив кулю 5, і промахнувся.
Автомат вистрелив кулю 6, і влучив.
...
</example>
</p>
<h5>Завдання 2 - на 12 балів</h5>
<p>Створити імітацію гри "однорукий бандит". Щоб подивитись опис даного завдання натисніть <a href="javascript:void(0)" onClick="idTxt3.style.display='block'">тут</a>.</p>
<div id="idTxt3" style="display:none;">
  <p>Наприклад, при натисненні кнопки "Enter" відбувається "обертання" трьох барабанів (кількість обертів кожного з них обирається довільно), на яких зображені різні значки; і якщо випадає певна комбінація, то гравець отримує довільний виграш.</p>
<p><b>Один з прикладів реалізації алгоритму:</b> Початкова кількість очків 1000. У випадку співпадіння трьох значень – виграш +1000 оч., двох – виграш +200, у всіх інших випадках знімається 100 оч. Якщо у користувача кількість очків стає рівна нулю – гра закінчується і виводиться питання: "Перезапустити гру?"</p>
  <p><b>Примітка.</b> Реалізація барабанів може бути основана на одному з розглянутих динамічних структур: стек або кільцева черга</p>
<p><b>Приклади реаізації програми:</b><br />
<img src="images\BlackJack_1.jpg" width="50%" align="left"/><img src="images\BlackJack_2.jpg" width="100%" />
</p><br clear="all" />
<p><img src="images\BlackJack_3.jpg" width="50%" align="left"/><img src="images\BlackJack_4.jpg" width="100%" /></p>
</div>
<br clear="all" />

  <hr/>
  <h3>Урок 13. Черга з пріоритетами та двухстороння.</h3>
   <p>написати програму, яка імітує чергу друку принтера (<b>Клас «Принтер»</b>). В програмі повинні бути наявні певні документи (клас «Документ»), які стають в чергу на друк. При цьому, кожен документ повинен мати свій пріоритет, який визначає його порядок в черзі.</p>
<p>Орієнтовний вигляд реалізації наступний: <br/><img src="images/printer.gif" /></p>
<p><b>ПРИМІТКА!</b> На 12 балів необхідно також реалізувати збеження статистики про друк документів (назва документа, час друку) в окремій черзі. Передбачити вивід статистики на екран. Без реалізації черги з статистичною інформацією завдання максимум оцінюється в 9 балів</p>
  <hr/>
 <h3>Урок 14. Динамічні структури даних. Списки. </h3>
<p>Побудувати клас для роботи з однозв’язним списком. Елемент списку містить наступну інформацію про <b>автобус</b>: 
<ol><li>номер автобуса;</li> 
<li>прізвище та ініціали водія; </li>
<li>номер маршруту. </li></ol>

Програма повинна забезпечувати: <ol><li>початкове формування двох списків: <ul><li>з даними про автобуси, які знаходяться в автопарку; </li>
<li>з даними про автобуси, які знаходяться на маршрутах.</li></ul>
При виїзді кождого автобуса з парку вводиться номер автобуса, і програма видаляє дані про цей автобус з списку автобусів, які знаходяться в автопарку, та записує ці дані в список автобусів, які знаходяться на маршруті.</li>
<li>аналогічна операція виконується для списків, якщо якийсь автобус повертається в автопарк;</li>
<li>по запиту видіються відомості про автобуси, які знаходяться в автопарку або на маршруті.</li>
</ol>
</p>
  <hr/>

<h3>Урок 15. Динамічні структури даних. Двійкові дерева.</h3>
<p>
Побудувати клас для роботи з бінарним деревом, який містить <b>англо-російський або англо-український словник</b>. Кожен вузол містить додатково лічильник звернень до слова в даному вузлі. В процесі експлуатації словника при кожному виклику слова в лічильник звернень додається одиниця.</p>
<p>
Написати програму, яка:<ol><li>забезпечить початкове введення словника з конкретними значеннями лічильника звернень;</li>
<li>формує нове представлення словника у вигляді бінарного дерева у відповідності до частоти звернень до слова;</li>
<li>здійснює вивід початкового і нового представлення словника.</li></ol>

Програма також надає інтерфейс типу «меню» та виконує пошук по вказаному ключу.</p>
<hr/>
<h3>Урок 16. Шаблони класів. </h3>
<h5>Постановка задачі</h5>
<p>Є магазин "Веселка". В даному магазині продається наступна продукція:<ul><li>книжки;</li><li>журнали;</li><li>аудіо диски.</li></ul>
Всі три види продукції представлені відповідними класами: Книга (Book), Журнал (Megazine), Аудіо диск (Audio). 
Програма має виводити наступні результати:<ol>
<li>Виводити інформацію про всі книги, журнали і/або аудіо диски.</li>
<li>Виводити інформацію про найдорожчу книжку, журнал і/або аудіо диск.</li>
<li>Виводити інформацію про найдешевшу книжку, журнал і/або аудіо диск.</li>
<li>Виводити середню ціну книг, журналів і/або аудіо дисків.</li>
<li>Виводити нові книги,  журнали і/або аудіо диски.</li>
</ol>
</p>
<h5>Хід розв’язку задачі</h5>
<p>Необхідно створити шаблонний <b>клас "CShop" (Магазин)</b>, який працює як звичайний шаблонний масив будь-якого типу та містить:<ol><li>поля:<ul><li>вказівник на тип масиву;</li>
<li>розмір масиву.</li></ul></li>
<li>дадаткові методи:<ul>
<li>пошук мінімального та максимального елемента масиву;</li>
<li>метод для сортування елементів масиву по зростанню або спаданню (наприклад, по ціні; на 12 балів);</li>
<li>метод для пошуку середнього арифметичного всіх елементів масиву;</li>
<li>перенавантажити оператор індексування.</li>
</ul></li></ol>
Необхідно також створити наступний <b>набір класів</b>:<ol><li>Книгa (Book), яка містить наступні поля:<ul><li>назва книги;</li>
<li>видавництво;</li>
<li>автор;</li>
<li>ціна;</li>
<li>булівське поле, яке вказує чи книга є нова: true – нова, false – ні.</li>
</ul></li>
<li>Журнал (Megazine), який містить наступні поля:<ul><li>назва журналу;</li>
<li>ціна;</li>
<li>булівське поле, яке вказує чи журнал є новим: true – новий, false – ні.</li></ul></li>
<li>Аудіо диск (Audio), який має містити наступні поля:<ul><li>назва диску;</li>
<li>виконавець;</li>
<li>кількість треків;</li>
<li>ціна;</li>
<li>булівське поле, яке вказує чи аудіо диск є новим: true – новий, false – ні.</li></ul></li>
</ol>
Для кожного класу написати необхідний набір методів.</p>
<p>В основній програмі, створити 3 об’єкти шаблонного класу "Магазин" для допустимих в програмі типів (Книги, Журнал, Аудіо диски). В результаті код набуде наступного вигляду: 
<example>
<![CDATA[ 
CShop<CBook>     b_shop = new CShop<CBook>();
CShop<CMagezine> m_shop = new CShop<CMagezine>();
CShop<CAudio>    a_shop = new CShop<CAudio>(); ]]>
</example>
Кожен параметричний об'єкт доповнити мінімум 2-ма елементами відповідного класу, заповнити масив необхідною інформацією та вивести її на консоль. А також виконати всі завдання вказані в постановці задачі.</p>
<hr/>
<h3>Урок 17. Директиви препроцесора. Простори імен</h3>
<p>Помістити класи "Журнал" та "Книга" попереднього домашнього завдання в окремий простір імен <b>publishing</b></p>
<hr/>
<h3>Урок 18. Успадкування. Одиничне успадкування.</h3>
<p>Опишіть класи <b>"Swordsman" (Мечник)</b>, <b>"Archer" (Лучник)</b> і <b>"Mage" (Маг)</b>, кожен з яких є екземпляром базового класу <b>"Unit" (штука, елемент)</b> в комп'ютерній грі, і може атакувати, ухилятись від атак і вмирати.</p>
<p>У мечника 15 хіт-поінтів (життів), пошкодження при атаці 5, шанс ухилятись 60%.<br/>
Лучник: 12 hp, 4 dmg, 40% dodge<br/>
Маг: 8 hp, 10 dmg, 30% dodge<br/>
</p>
<p>В main() створіть два масива (ворогуючі сторони) по три юніта в кожному, причому тип юніта (мечник, лучник чи маг) має задаватись випадково, при заповненні цих масивів. Тобто один раз запустивши вашу програму, може створитись три лучники проти мечника і двох магів, іншого - лучник, мечник і маг проти двох мечників і лучника і т.д.</p>
<p>Далі в циклі земулюйте бій між ними, поки бійці однієї з сторін всі не загинуть. В консоль при цьому виводьте повідомлення хто кого атакував, чи вдалась атака, скільки життя залишилось у жертви чи вона загинула. Нехай бій відбувається поступово, по натиснення клавіші spacebar (пробіла), щоб ми могли спостерігати його атака за атакою.</p>
<p>В кінці бою оголосіть, яка команда перемогла (перша/друга, синя/червона, альянс/орки - як вже ваша фантазія вам підскаже).</p>
<p>Не забудьте здійснити приведення типів там, де це необхідно.</p>
<hr />
<h3>Урок 19. Множинне успадкування. Раннє та пізнє зв’язування. Віртуальні методи класу</h3>
<p>Описати клас <b>"Fortress" (Фортеця)</b>.</p>
<p> Для початку, напишіть клас <b>"Shooter" (стрілець)</b>, який буде містити два поля: назва аммуніції та її кількість. Він може виконати дію "постріл" і витратити для цього одиницю амуніції, повідомляючи в консоль, як вона називалась. А також може здійснити дію "дати амуніцію", яка встановлюватиме назву і кількість амуніції, отримуючі ці дані через параметри.</p>
<p>Стрілець має три дочірні класи: <b>"Archer" (Лучник)</b>, <b>"Ranger" (Рейнджер)</b> та <b>"Catapult" (Катапульта)</b>, які заміщають дію "постріл", доповнюючи повідомлення в консоль інформацією про те, хто саме з них вистрілив. Перші два повинні стріляти стрілами, а катапульта - каменями.</p>

<p>Від перших двох породжується клас <b>"ArcherTower" (Cтрілкова вежа)</b>, у якої запас амуніції має бути один (спільний) для обох: лучника і рейнджера (подумайте, який механізм множинного успадкування тут варто застосувати). </p>
<p>Від класів "стрілкова вежа" і "катапульта" має походити клас <b>"Fortress"</b>. Лише в її конструкторі мають поставлятись стріли для стрілкової вежі і камені для катапульти. Додайте до фортеці ще кілька полів - товщина стін, стан воріт у відсотках, і т.д. - по вашому бажанню та фантазії.</p>

<p>Більше <u>ніяких допоміжних методів чи об'єктів</u> створювати не потрібно. В кожного з полів чи методів у цій ієрархії має бути встановлений максимальний рівень захисту, і успадкування має відбуватись по найвищо-допустимому по захисту специфікаторові доступу. Але таким, щоб в main() можна було виконати наступне: <ol><li>створити об'єкт фортеці</li><li>вистрілити тричі лучником, двічі рейнджером і раз з катапульти</li></ol>
Отже, всього має бути 6 класів, вінцем творіння і фінальним дитям серед них є клас "Фортеця", <u>лише один об'єкт якої буде створено</u>. Зверніть на це увагу - 6 класів описано, всі використовуються. Але об'єкт у всій програмі один.</p>

<p><b>ПРИМІТКИ!</b> Коли створюватиметься фортеця, доставте в стрілкову вежу лише 4 стріли, тоді буде явно видно, що на другий постріл рейнджеру стріл не вистачить, оскільки лучник перед тим витратив 3 із 4-х стріл.</p>
<hr/>
<h3>Урок 20. Віртуальний та абстрактний базовий клас</h3>
<p>Переписати завдання уроку 19 таким чином, щоб клас "Fortress" (Фортеця) був віртуальним базовим класом, а отже, мав конструктор по замовчуванню (він буде викликатись перед всіма іншими конструкторами в ієрархії успадкування. Він може бути як автоматичним, так і описаним вами).</p>
<hr/>
<h3>Урок 21. Файли. Короткий повтор роботи з файлами засобами С. Аргументи командного рядка та пошук файлів</h3>
<p>Написати програму, яка здійснює пошук всіх текстових файлів у вказаному каталозі та виводить їх у вигляді нумерованого списка. Назва каталога береться з командного рядка. Користувач обирає в списку та відкриває (функціями бібліотеки С) текстовий файл для подальшої роботи. </p>
<p>Організувати цикл, який запитує в користувача позицію в файлі, після чого програма повинна роздрукувати частину файла, починаючи з введеної позиції і до наступного символа нового рядка. Цикл закінчується, коли вводиться нечисловий символ.</p>
  <hr/>
<h3>Урок 22. Файли. Файлові потоки введення/виведення</h3>
  <p>Написати програму, яка дозволяє записувати в файл інформацію про результати сесії (оцінки) певної групи студентів. Організувати зчитування даної інформації з файлу та підрахунок середнього балу в групі.</p>
<p>Використайте, розроблені в уроці 6 класи Group ("Група") та Student ("Студент"). Додати методи Save() та Read() для запису та зчитування обєктів в/з файла.</p>

  <h5>Додаткове необов'язкове завдання (додаткових 12 балів)</h5>
  <p>Написати програму, яка виводить статистику по вказаному користувачем файлу в наступному вигляді:
<ul>
<li>кількість коротких слів (який складається максимум з 10 символів);</li>
<li>кількість великих слів;</li>
<li>кількість цифр;</li>
<li>кількість символів пунктуації, наприклад, (!), (,), (.), (-).</li>
</ul>
Крім того, у відповідь на написанення довільної клавіши або на певний пункт меню, здійснити заміну всіх цифр в файлі на символи (*), а додатково (на 12 балів) зробити видалення всіх символів пунктуації.</p>
<hr/>
<h3>Урок 23. Виключення. Оператор typeid.</h3>
  <h5>Завдання 1</h5>
<p>Модифікуйте правила бою з домашньої роботи "Сутичка" (Урок 18) так, щоб кожен боєць (Воїн, Лучник чи Маг) вишукував серед ворогів суперника свого типу і атакував його. Скажемо, якщо маємо команди:<br />
A11 - M21<br />
A12 - S22<br />
S13 - A23<br />
...то А11 має вибрати своєї ціллю А23.</p>
<p>Якщо ворогів свого типу не знайдено, нехай генерується відповідне повідомлення про помилку та бійці атакують по старим правилам (тим, що ви написали раніше).</p>
  <h5>Завдання 2</h5>
<p>
Передбачте у попередньому домашньому завданні (урок 22, завдання 2), щоб у випадку виникнення помилок (наприклад, при зчитуванні або записі у файл, введенні невірного значення імені студента тощо) відловлювались відповідні виключення.</p>
<hr/>
  <h3>Урок 24. STL. Ітератори та контейнери</h3>
  <h5>Завдання 1</h5>
  <p>Написати реалізацію класу <b>stack</b> бібліотеки STL на основі елементів типу double. Основна програма повинна містити код створення об'єкта, після чого потрібно "програти" методи даного класу. Оцінка залежить від повноти реалізації методів даного класу.</p>
  <h5>Завдання 2</h5>
  <p>Написати реалізацію класу <b>queue</b> бібліотеки STL на основі елементів типу string. Основна програма повинна містити код створення об'єкта, після чого потрібно "програти" методи даного класу. Оцінка залежить від повноти реалізації методів даного класу.</p>
  <h5>Завдання 3</h5>
<p>Написати програму, яка використовує клас <b>string</b> бібліотеки STL для аналізу рядка, що містить математичний вираз, наприклад, вигляду - (2+3)*4+1. Рядок вводиться з клавіатури. Програма видає результат обрахунку виразу</p>
<hr/>
  <h3>Урок 25. STL. Функтори, алгоритми та адаптери</h3>
  <h5>Завдання 1</h5>
  <p>Створити <b>multimap та multiset</b> (класи бібліотеки STL) на основі елементів типу класу CPerson, що містить в своєму класі наступні обов’язкові поля: ім’я, прізвище, вік. <b>Вимоги:</b> обов’язково реалізувати пошук особи по будь-якій з ознак та обов’язковим є наявність меню в програмі. Оцінка залежить від повноти реалізації методів даного класу.</p>
  <h5>Завдання 2</h5>
  <p>Придумати та реалізувати довільний унарний та бінарний функтор. Наприклад, унарний функтор збільшення числа в кілька разів або обрахунку кореня квадратного та бінарний функтор порівняння двох чисел, переданих в якості параметрів.</p>
</lesson>