<?xml version="1.0" encoding="windows-1251" ?>
<?xml:stylesheet type="text/xsl" href="common/layout.xsl" ?>

<lesson title="ООП" next="section20C.xml" prev="section18HC.xml" summ="1">

<h2>19С. Домашні завдання по курсу ООП</h2>
  <h3>Урок 1. Класи. Конструктори та деструктори.</h3>
<h5>Завдання 1</h5>
<p>
Створити клас <b>"Точка" (Point)</b>, який складається з двох полів типу int: X та Y. Необхідно забезпечити:
<ol>
<li>Введення координат точки користувачем</li>
<li>Вивід інформації про точку на екран</li>
<li>Можливість зміни будь-якої з координат на запит користувача (X або Y)</li>
</ol>
</p>
<h5>Завдання 2</h5>
<p>Написати клас <b>"Банківський рахунок" (Account)</b>, який містить:
<ul>
<li>Номер рахунку</li>
<li>Розмір коштів на рахунку</li>
<li>Назва валюти рахунку (рублі, гривні, евро тощо), для позначення якої можна скористатись одним символом: R, G, E, $ тощо</li>
</ul>
Забезпечити можливість:
<ol>
<li>Відкривати рахунок та первинно вносити гроші на рахунок</li>
<li>Знімати гроші з рахунку</li>
<li>Докладати гроші на рахунок</li>
</ol>
<b>ПРИМІТКА!</b> На 12 балів реалізувати також можливість здійснювати переказ грошей з одного рахунку на другий.
</p>
<hr/>
<h3>Урок 2. Конструктори з параметрами. Постійні методи класу. Об'єкти класу та функції</h3>
<p>Створити клас <b>Int</b>, що імітує роботу стандартного типу int. Наприклад, код основної програми (в функції main()) буде мати наступний вигляд:</p>
<example>
//при використанні змінних стандартного типу int
int a = 5, b = 2, res = 0;
res = a + b;
<![CDATA[cоut << res << еndl; ]]>

//при використанні обєктів типу cInt, аналогічний код буде мати викляд
cInt a(5), b(2), res;
res = a.Sum(b);
<![CDATA[cоut << res.GetValue() << еndl; ]]>
</example>
<p>Єдине поле даного класу повинно мати тип int.</p><p> Створіть методи, які будуть встановлювати значення поля рівним нулю, ініціалізувати його цілим значенням, виводити значення поля на екран та додавати два значення типу Int, а також конструктор стандартний та з параметром.</p>
<p>
Напишіть програму, в якій будуть створені три об’єкта класу Int, два з яких будуть ініціалізовані. Додайте два ініціалізованих об’єкта, присвойте результат третьому, а потім відобразіть результат на екран.</p>
<p><b>ПРИМІТКА!</b> На 12 балів реалізувати також метод, який робить дію аналогічну операції *=.</p>
<hr/>
<h3>Урок 3. Взаємодія об'єктів кількох класів. Розбивка по файлам. Класи, об'єкти та пам'ять</h3>
<h5>Завдання 1</h5>
<p>
Написати клас <b>"Карточка на знижку" (DiscountCard)</b>, який містить наступну інформацію:
<ul>
<li>Номер карточки</li>
<li>Розмір знижки (знижка передбачається накопичуваною; на початковому етапі вона рівна 1%. За кожні 1000 грн. покупки, сума знижки збільшується на 1%.)</li>
<li>Приховане допоміжне поле для збереження вартості накупленого товару</li>
<li>Дата видачі карточки, яка має тип <b>CDate</b>  (клас CDate орієнтовно містить наступні поля та методи: month, day, year, SetDate() та ShowDate() в форматі "12/02/1200")</li>
</ul>
Забезпечити можливість:
<ol>
<li>Купляти товар з використанням карточки на знижку;</li>
<li>Виводити інформацію про поточну величину знижки;</li>
<li>Виводити інформацію про те, на яку суму ще необхідно докупити товару, щоб величина знижки збільшилась.</li>
</ol>
</p>
<h5>Завдання 2</h5>
<p>Написати клас, який описує цифровий лічильник. <b>Лічильник</b> – це змінна з обмеженим діапазоном, значення якої скидається, коли воно досягає певного максимуму (наприклад, counter приймає значення в діапазоні 0..5). Необхідно забезпечити:<br/>
    -	Можливість встановлення максимального та мінімального значень.<br/>-	Збільшення лічильника на 1.<br/>
    -	Повернення поточного значення.<br/>-	Використати постійні методи там, де це необхідно.
  </p>
<p>Орієнтовний приклад реалізації програми:<br/> <img src="images/counter.gif" /></p>
<hr />
  <h3>Урок 4. Вказівники на об’єкти. Об’єкти та масиви об’єктів в області динамічної пам’яті. Масиви вказівників. Постійні в якості вказівників на методи класу. Вказівник this.</h3>
  <h5>Завдання 1</h5>
  <p>Створити клас <b>Person</b>, що містить в собі відповідні члени для збереження наступних даних:<br/>
-	ім'я (char*);<br/>-	вік<br/>-	стать;<br/>-	телефонний номер (char*).</p>
     <p>Клас повинен також містити необхідний набір конструкторів, стандартних методів доступу до полів класу, а також метод Print(), який виводить відформотовані дані про особу на екран.</p>
<p>
    <b>Вимоги:</b><br/>
    -	змінна, що містить інформацію про телефонний номер, повинна бути динамічною, тобто зберігати свої дані в кучі;<br/>
    - необхідно створити динамічний масив працівників;<br/>-	в методі Print явно використати вказівник this.</p>
 <h5>Завдання 2</h5>
  <p>Необхідно створити клас <b>Monitor</b>, який повинен містити:<ol>
<li>поля:<ul>
<li>технічні характеристики (тип, роздільна здатність, розмір тощо);</li>
<li>ціна монітору.</li>
</ul></li>
<li>методи:<ul>
<li>Конструктор по замовчуванню та з параметрами;</li>
<li>Стандартні методи доступу до полів класу;</li>
<li>Методи для встановлення значень в поля класу;</li>
<li>Метод для виведення полів класу на консоль.</li>
</ul></li></ol>
В основній програмі реалізувати можливість здійснення наступних дій:
<ul>
<li>створити мінімум 4 об’єкти класу Monitor;</li>
<li>зробити пошук монітора по заданих характеристиках;</li>
<li>підрахувати та вивести окремі ціни та загальну вартість всіх моніторів на екран.</li>
</ul>
Об’єкти класу повинні створюватись різними способами:
<ul>
<li>мінімум один з об’єктів конструктором по замовчуванню і встановлення значень полів для даного об’єкта через методи (set);</li>
<li>мінімум один об’єкт через конструктор з параметрами.</li>
</ul></p>
<hr />
<h3>Урок 5. Вказівники на функції-члени класу. Конструктор копій </h3>
<p>
Написати програму роботи з поїздами, на основі класу <b>Train ("Поїзд")</b>. Програма пропонує ввести з клавіатури:<ul><li>Кількість поїздів;</li>
<li>Кількість вагонів для кожного поїзда.</li></ul>

На основі ведених даних створюються поїзди, виводиться загальна інформація про них та набір наступних звітів:<ol>
<li>Поїзд в якому їхала найбільша кількість пасажирів.</li>
<li>Поїзд в якому їхала найменша кількість пасажирів.</li>
</ol>

Клас <b>Train</b> повинен містити:<ol>
<li>поля:<ul>
<li>номер поїзда;</li>
<li>назва поїзда (сполучення наприклад "Львів - Київ");</li>
<li>поле "вагон" - вказівник на тип int, якому буде виділятися динамічна пам'ять розміром в кількість вагонів, де індекс даного масиву вказує на номер вагону, а значення комірки масиву на кількість пасажирів у вагоні;</li>
<li>кількість вагонів.</li>
</ul></li>
<li>методи:<ul><li>Конструктор по замовчуванню;</li>
<li>Конструктор з параметрами;</li>
<li>Конструктор копіювання;</li>
<li>Стандартні методи доступу до полів класу;</li>
<li>Метод для виведення інформації про поїзд:<ul>
<li>Загальна кількість пасажирів.</li>
<li>Загальна кількість вагонів.</li>
<li>Номер вагону в якому їхала найменша кількість пасажирів</li>
<li>Номер вагону в якому їхала найбільша кількість пасажирів.</li>
</ul>
</li>
<li>Метод для знаходження вагона з максимальною кількість пасажирів;</li>
<li>Метод для знаходження вагона з мінімальною кількість пасажирів;</li>
<li>Метод для знаходження загальної кількості пасажирів в поїзді.</li>
</ul></li>
</ol>
</p>
   <hr/>
  <h3>Урок 6. Підсумкова практична частина по І розділу</h3>
  <h5>Завдання 1</h5>
 <p>
    Розробити клас <b>XString</b>, який далі буде використовуватися для роботи з рядками. Клас повинен містити:
    <ul><li>конструктор по замовчуванню, який дозволяє створити рядок довжиною 80 символів;</li>
    <li>конструктор, який дозволяє створити рядок довільного розміру;</li>
    <li>конструктор, який створює рядок та ініціалізує його рядком, отриманим від користувача;</li>
    <li>конструктор копій.</li></ul>
    Клас повинен мати також методи для вводу рядків з клавіатури і виводу рядків на екран.
  </p>
  <h5>Завдання 2</h5>
  <p>
    Створити клас <b>Group ("Група")</b>, що містить в собі наступні поля:<br/>
    -	назва групи<br/>-	курс<br/> -	назва спеціальності (char *)<br/>-	масив студентів, що також описаний окремим класом <b>Student</b>.
  </p><p>
    Даний клас містить набір методів, що дозволяють:<br/>
    -	здійснити модифікацію окремих полів класу (назви групи, курсу та спеціальності)<br/>-	вивести інформацію про групу вцілому<br/> -	змінювати інформацію про студентів.</p>
 <hr/>

  <h3>Урок 7. Перевантаження операторів. Перевантаження арифметичних операцій та оператора присвоєння.</h3>
  <p>Створіть клас <b>Date</b>, який буде містити інформацію про дату (день, місяць, рік). За допомогою механізму перегрузки операторів, визначіть:
<ol><li>операцію різниці між двома датами (результат в вигляді кількості днів між датами);</li>
  <li>операцію збільшення дати на певну кількість днів;</li><li>операцію збільшення дати в певну кількість раз ( * );</li>
    <li>операцію знаходження суми дат ( + );</li><li>операцію, яка дозволить перевстановити дату ( = ).</li></ol>
   Всю роботу організувати через систему меню.
  </p>
<hr/>
  <h3>Урок 8. Перевантаження логічних операцій та операцій порівняння. Перевантаження оператора неявного приведення до типу</h3>
  <p>
Реалізувати клас <b>var («Універсальна змінна»)</b>. Об’єкти екземпляра цього класу можуть зберігати в собі значення наступних типів: int, double, XString (рядок, – створений вами клас). Наприклад:
<example>
void main()
{
	var a = 15;
	var b = “Hello”;
	var c = 7.8;
	var d = “50”;
	b = a + d;
	b.Show();		//отримаємо 65
	<![CDATA[  
	if (a == b) cout << “Equal”<<endl; 
	else cout << “Not Equal”<<endl;]]>
}
</example>
</p><p>
Для класу var необхідно перевантажити:<ul><li>арифметичні оператори: +, -, *, /, +=, -=, *=, /=</li>
<li>оператори порівняння: <![CDATA[  <, >, <=, >=, ==, != ]]></li></ul>
Додати також до класу var приведення до типу: int, double, char*.</p>

<h5>Основні моменти:</h5>
<p>В змінній типу var в довільний момент часу може знаходитись лише одне значення (int або double, або ХString).</p>
<p>При перевантаженні операторів слід врахувати наступне: якщо при виконанні операції типи значень двох операндів типу var різні, тоді необхідно приводити (конвертувати) значення другого операнда до типу значення першого операнда і тільки після цього виконувати операцію. При цьому значення і тип другого операнда в самому об’єкті var не змінюється. Наприклад:
<example>
	var a = 10, b = “120”, c;
	c = a + b;
	c.Show();		//отримаємо 130
	c = b + a;
	c.Show();		//отримаємо “12010”
</example>
Для типу XString:<ul><li>операція * повинна повертати новий рядок, який утворюється шляхом перетину двох рядків, тобто їх спільні символи. Наприклад, результатом перетину рядків "Microsoft" та "Windows" буде рядок "ioso".</li>
<li>операція / повинна повертати новий рядок, який утворюється шляхом відбору символів першого рядка, яких немає в другому. Наприклад, результатом ділення рядка "Microsoft" на "Windows" буде рядок "Mcrft".</li>
<li>операцію + , що дозволяє додати два рядки – конкатенація рядків.</li>
<li>операцій *=, /= та +=, які діють по вищеописаному принципу.</li>
<li>оператор ! (NOT), що дозволить здійснити реверс рядка.</li>
</ul></p>
<hr/>
 <h3>Урок 9. Дружні конструкції. Перевантаження операторів направлення потоку<![CDATA[ ( >>, << ) та індексування ( [ ] ).]]></h3>
  <p>Створити клас Vector, який має два змінних-члени: сам вектор (double*) та його розмір. Даний клас має наступні методи:<br/>
    -	Стандартний конструктор;<br/>
  -	Перевантажений конструктор, який забороняє неявне приведення до типу та дозволяє задавати розмір вектора;<br/>
  -	Конструктор, що дозволяє ініціалізувати вектор іншим масивом;<br/>
  -	Конструктор копій;<br/>
  -	Деструктор;<br/>
  -	Збільшення всіх елементів вектора на 1 ( ++ ) (постфікс та префікс). Причому перевантаження префіксного інкремента організувати поза межами класу;<br/>
  -	Зменшення всіх елементів вектора на 1 ( -- ) (постфікс та префікс). Причому перевантаження постфіксного декремента організувати поза межами класу;<br/>
  -	Присвоювання вектора;<br/>
  -	Метод, що дозволяє доступатись по індексу ( [ ] );<br/>
  -	Методи додавання та віднімання двух векторів (+, -, +=, - =);<br/>
  -	Методи додавання та віднімання до/від вектора числа (+, -, +=, - =);<br/>
  -	Множення двух векторів та множення вектора на число;<br/>
  -	Введення та виведення вектора <![CDATA[(<<, >>)]]>;<br/>
  -	Метод,що повертає розмірність вектора;<br/>
  -	Методи, що дозволяють порівнювати два вектори (оператори порівняння та логічні оператори).
  </p>
  <hr/>
<h3>Урок 10. Статичні члени та методи класу. Перевантаження оператора виклику функцій ( ( ) ). Перевантаження операторів new, delete, new [], delete []</h3>
<h5>Завдання 1</h5>
<p>Доповнити створений раніше клас Vector статичною змінною-членом класу, що буде підраховувати кількість векторів, та статичним методом класу, що дозволить отримати дані з статичної змінної. Також для вектора перевантажити оператор виклику функції, що дозволить обновляти об’єкт значеннями нового масиву (дана операторна функція повинна містити два параметри – масив типу double* та його розмір).</p>
<h5>Завдання 2</h5>
<p>Створити клас для роботи з матрицями. Передбачити функції для додавання ( + ), множення двох матриць ( * ), транспонування матриць ( ! ), присвоєння матриць одна одній, встановлення та отримання довільного елемента матриці. Необхідно перевантажити відповідні оператори</p>
<hr />
<h3>Урок 11. Оператори * (розіменування), -> (доступу по вказівнику)</h3>
<p>Доробити всі заборгованості</p>
<hr/>
<h3>Урок 12. Динамічні структури даних. Стек. Проста та кільцева черга</h3>
<p>Реалізуйте одне завдання на ваш вибір</p>
<h5>Завдання 1</h5>
  <p>Створити імітацію гри "однорукий бандит". Наприклад, при натисненні кнопки "Enter" відбувається "обертання" трьох барабанів (кількість обертів кожного з них обирається довільно), на яких зображені різні значки; і якщо випадає певна комбінація, то гравець отримує довільний виграш.</p>
<p><b>Один з прикладів реалізації алгоритму:</b> Початкова кількість очків 1000. У випадку співпадіння трьох значень – виграш +1000 оч., двох – виграш +200, у всіх інших випадках знімається 100 оч. Якщо у користувача кількість очків стає рівна нулю – гра закінчується і виводиться питання: "Перезапустити гру?"</p>
  <p><b>Примітка.</b> Реалізація барабанів може бути основана на одному з розглянутих динамічних структур: стек або кільцева черга</p>
<p><b>Приклади реаізації програми:</b><br />
<img src="images\BlackJack_1.jpg" width="50%" align="left"/><img src="images\BlackJack_2.jpg" width="100%" />
</p><br clear="all" />
<p><img src="images\BlackJack_3.jpg" width="50%" align="left"/><img src="images\BlackJack_4.jpg" width="100%" /></p>
<br clear="all" />
<h5>Завдання 2</h5>
<p>Напишіть програму з трьома класами - автомат, обойма, куля. Кожна куля пронумерована, обойма реалізована у вигляді стеку і містить 30 куль. Автомат вміє:<ol><li>заряджати кулю в обойму</li> 
<li>стріляти - виштовхувати кулю з обойми, і влучати в мішень з долею вірогідності 70%.</li></ol>При пострілі в консоль має виводитись повідомлення такого типу:
<example>
Автомат вистрелив кулю 5, і промахнувся.
Автомат вистрелив кулю 6, і влучив.
...
</example>
</p>
  <hr/>
  <h3>Урок 13. Черга з пріоритетами та двухстороння.</h3>
   <p>написати програму, яка імітує чергу друку принтера (Клас «Принтер»). В програмі повинні бути наявні певні документи (клас «Документ»), які стають в чергу на друк. При цьому, кожен документ повинен мати свій пріоритет, який визначає його порядок в черзі. Необхідно зберігати статистику друку (документ, час) в окремій черзі. Передбачити вивід статистики на екран.</p>
  <hr/>

<h3>Урок 14. Динамічні структури даних. Списки. </h3>
<p>Побудувати клас для роботи з однозв’язним списком. Елемент списку містить наступну інформацію про <b>автобус</b>: 
<ol><li>номер автобуса;</li> 
<li>прізвище та ініціали водія; </li>
<li>номер маршруту. </li></ol>

Програма повинна забезпечувати: <ol><li>початкове формування двох списків: <ul><li>з даними про автобуси, які знаходяться в автопарку; </li>
<li>з даними про автобуси, які знаходяться на маршрутах.</li></ul>
При виїзді кождого автобуса з парку вводиться номер автобуса, і програма видаляє дані про цей автобус з списку автобусів, які знаходяться в автопарку, та записує ці дані в список автобусів, які знаходяться на маршруті.</li>
<li>аналогічна операція виконується для списків, якщо якийсь автобус повертається в автопарк;</li>
<li>по запиту видіються відомості про автобуси, які знаходяться в автопарку або на маршруті.</li>
</ol>
</p>
  <hr/>
<h3>Урок 15. Динамічні структури даних. Двійкові дерева.</h3>
<p>
Побудувати клас для роботи з бінарним деревом, який містить <b>англо-російський або англо-український словник</b>. Кожен вузол містить додатково лічильник звернень до слова в даному вузлі. В процесі експлуатації словника при кожному виклику слова в лічильник звернень додається одиниця.</p>
<p>
Написати програму, яка:<ol><li>забезпечить початкове введення словника з конкретними значеннями лічильника звернень;</li>
<li>формує нове представлення словника у вигляді бінарного дерева у відповідності до частоти звернень до слова;</li>
<li>здійснює вивід початкового і нового представлення словника.</li></ol>

Програма також надає інтерфейс типу «меню» та виконує пошук по вказаному ключу.</p>
<hr/>
<h3>Урок 16. Шаблони класів. </h3>
<h5>Постановка задачі</h5>
<p>Є магазин "Веселка". В даному магазині продається наступна продукція:<ul><li>книжки;</li><li>журнали;</li><li>аудіо диски.</li></ul>
Всі три види продукції представлені відповідними класами: Книга (Book), Журнал (Megazine), Аудіо диск (Audio). 
Програма має виводити наступні результати:<ol>
<li>Виводити інформацію про всі книги, журнали і/або аудіо диски.</li>
<li>Виводити інформацію про найдорожчу книжку, журнал і/або аудіо диск.</li>
<li>Виводити інформацію про найдешевшу книжку, журнал і/або аудіо диск.</li>
<li>Виводити середню ціну книг, журналів і/або аудіо дисків.</li>
<li>Виводити нові книги,  журнали і/або аудіо диски.</li>
</ol>
</p>
<h5>Хід розв’язку задачі</h5>
<p>
Необхідно створити шаблонний <b>клас "Масив"</b>, який має забезпечити роботу з масивом будь-якого типу та містить:<ol><li>поля:<ul><li>вказівник на тип масиву;</li>
<li>розмір масиву.</li></ul></li>
<li>дадаткові методи:<ul>
<li>пошук мінімального та максимального елемента масиву;</li>
<li>метод для сортування елементів масиву по зростанню або спаданню;</li>
<li>метод для пошуку середньо арифметичного всіх елементів масиву;</li>
<li>перенавантажити оператор індексування.</li>
</ul>
</li>
</ol>
Необхідно також створити наступний <b>набір класів</b>:<ol><li>Книгa (Book), яка містить наступні поля:<ul><li>назва книги;</li>
<li>видавництво;</li>
<li>автор;</li>
<li>ціна;</li>
<li>булівське поле, яке вказує чи книга є нова: true – нова, false – ні.</li>
</ul></li>
<li>Журнал (Megazine), який містить наступні поля:<ul><li>назва журналу;</li>
<li>ціна;</li>
<li>булівське поле, яке вказує чи журнал є новим: true – новий, false – ні.</li></ul></li>
<li>Аудіо диск (Audio), який має містити наступні поля:<ul><li>назва диску;</li>
<li>виконавець;</li>
<li>кількість треків;</li>
<li>ціна;</li>
<li>булівське поле, яке вказує чи аудіо диск є новим: true – новий, false – ні.</li></ul></li>
</ol>
Для кожного класу написати необхідний набір методів, а також перевантажити наступні оператори: &lt;, &gt;, !=, ==,  =, +, +=. Крім того, класи "Журнал" та "Книга" повинні бути розміщені в окремому просторі імен <b>publishing</b>.
</p><p>
В основній програмі, створити 3 об’єкти шаблонного класу "Масив" для допустимих в програмі типів (Книги, Журнал, Аудіо диски). Кожен параметричний обєкт доповнити мінімум 3-ма елементами відповідного класу, заповнити масив необхідною інформацією та вивести її на консоль. А також виконати всі завдання вказані в постановці задачі.</p>
<hr/>

<h3>Урок 17. Директиви препроцесора. Простори імен</h3>
<h5>Завдання 1</h5>
<p>Помістити класи "Журнал" та "Книга" попереднього домашнього завдання в окремий простір імен <b>publishing</b></p>
<h5>Завдання 2</h5>
<p>Створити програму, яка фільтрує текст, введений з клавіатури. Задача програміста заключається в зчитуванні тексту і відображенні його на екрані, використовуючи заміну заданого набору символів на пропуски або довільний символ, наприклад, "*". Програма повинна пропонувати наступні 
варіанти наборів символів для заміни (фільтрації):<ul><li>Символи латинського алфавіту</li>
<li>Символи кирилиці </li>
<li>Цифри </li></ul>
Фільтри можуть накладуватися послідовно. При повторному встановленні існуючого фільтра даний фільтр повинен зніматися.</p>
<p>Організувати створення фільтрів, використовуючи дерективи препроцесора</p>
<hr/>

<h3>Урок 18. Успадкування. Одиничне успадкування.</h3>
<p>Опишіть клас <b>Vehicle (транспортний засіб)</b>, який матиме наступні поля:
<ul><li>fuel (запас пального)</li><li>fuel_max (ємкість паливного баку)</li><li>color (колір транспортного засобу)</li></ul>
Напишіть необхідні конструктори, щоб проініціалізувати ці поля, і метод go(int dist, float fuel_100km), який витратить одиницю пального на одиницю відстані (вказується через параметр), і виведе повідомлення про те, що транспортний засіб проїхав цю відстань. Затрати пального на 100 одиниць відстані передаються в якості другого параметра даного метода. БІЛЬШЕ НІЯКИХ МЕТОДІВ! Набір конструкторів та деструкторів по необхідності.</p>
<p>Після цього:<ol><li>Створіть дочірний щодо класу Vehicle клас <b>Tank (Танк)</b>, що ініціалізуватиме при створенні свої поля топлива, баку і кольору;</li>
<li>Додайте приватне поле - стек снарядів (по аналогією з Д.З., де в автомата був стек куль. Тобто, кожен снаряд має свій серійний номер). Кількість снарядів, що буде міститись в танку теж повинна задаватись через конструктор;</li>
<li>Напишіть метод shoot(), який вистрілюватиме снаряд зі стеку, повідомляючи в консоль про серійний номер снаряду, що вистрілився;</li>
<li>Перевизначте метод go() так, щоб танк не тільки витрачав пальне, коли їздить на задану відстань, а ще й після того вистрелював один раз. У метода go() повинно так і залишатись два параметри - відстань, на яку необхідно поїхати, та затрати пального на 100 одиниць відстані.</li></ol>

В main() напишіть наступні <b><u>тести</u></b>:<ol type="a"><li>створіть червону машину з заправленими 10 літрами палива із 30</li>
<li>проїдьте нею 2 одиниці відстані (наприклад, км)</li>
<li>створіть зелений танк із 80 літрами палива із 100</li>
<li>проїдьте ним 25 км, не стріляючи</li>
<li>вистреліть двічі</li>
<li>проїдьте 50 км з пострілом в кінці поїздки</li>
<li>спробуйте проїхати ще 10 км з пострілом в кінці, внаслідок чого має вивестись повідомлення про недостатню кількість пального, поїздки не відбутись, і постріли теж.</li></ol>
</p>
<hr/>
<h3>Урок 19. Множинне успадкування. Раннє та пізнє зв’язування. Віртуальні методи класу</h3>
<p>Описати клас <b>"Fortress" (Фортеця)</b>.</p>
<p> Для початку, напишіть клас <b>"Shooter" (стрілець)</b>, який буде містити два поля: назва аммуніції та її кількість. Він може виконати дію "постріл" і витратити для цього одиницю амуніції, повідомляючи в консоль, як вона називалась. А також може здійснити дію "дати амуніцію", яка встановлюватиме назву і кількість амуніції, отримуючі ці дані через параметри.</p>
<p>Стрілець має три дочірні класи: <b>"Archer" (Лучник)</b>, <b>"Ranger" (Рейнджер)</b> та <b>"Catapult" (Катапульта)</b>, які заміщають дію "постріл", доповнюючи повідомлення в консоль інформацією про те, хто саме з них вистрілив. Перші два повинні стріляти стрілами, а катапульта - каменями.</p>

<p>Від перших двох породжується клас <b>"ArcherTower" (Cтрілкова вежа)</b>, у якої запас амуніції має бути один (спільний) для обох: лучника і рейнджера (подумайте, який механізм множинного успадкування тут варто застосувати). </p>
<p>Від класів "стрілкова вежа" і "катапульта" має походити клас <b>"Fortress"</b>. Лише в її конструкорі мають поставлятись стріли для стрілкової вежі і камені для катапульти. Додайте до фортеці ще кілька полів - товщина стін, стан воріт у відсотках, і т.д. - по вашому бажанню та фантазії.</p>

<p>Більше ніяких допоміжних методів чи об'єктів створювати не потрібно. В кожного з полів чи методів у цій ієрархії має бути встановлений максимальний рівень захисту, і успадкування має відбуватись по найвищо-допустимому по захисту специфікаторові доступу. Але таким, щоб в main() можна було виконати наступне: <ol><li>створити об'єкт фортеці</li><li>вистрілити тричі лучником, двічі рейнджером і раз з катапульти</li></ol>

  Отже, всього має бути 6 класів, вінцем творіння і фінальним дитям серед них є клас "Фортеця", лише один об'єкт якої буде створено. Зверніть на це увагу - 6 класів описано, всі використовуються. Але об'єкт у всій програмі один.</p>

<p><b>ПРИМІТКИ!</b> Коли створюватиметься фортеця, доставте в стрілкову вежу лише 4 стріли, тоді буде явно видно, що на другий постріл рейнджеру стріл не вистачить, оскільки лучник перед тим витратив 3 із 4-х стріл.
<!-- <ol><li>віртуальний базовий клас зобов'язаний мати конструктор по замовчуванню - він буде викликатись перед всіма іншими конструкторами в ієрархії успадкування. Він може бути як автоматичним, так і описаним вами.</li>
<li>коли створюватиметься фортеця, доставте в стрілкову вежу лише 4 стріли, тоді буде явно видно, що на другий постріл рейнджеру стріл не вистачить, оскільки лучник перед тим витратив 3 із 4-х стріл.</li></ol>-->
</p>
<hr/>
<h3>Урок 20. Віртуальний та абстрактний базовий клас</h3>
<p>Опишіть класи <b>"Swordsman" (Мечник)</b>, <b>"Archer" (Лучник)</b> і <b>"Mage" (Маг)</b>, кожен з яких є екземпляром базового абстрактного класу <b>"Unit" (штука, елемент)</b> в комп'ютерній грі, і може атакувати, ухилятись від атак і вмирати. Ці методи повинні бути чистими віртуальним функціями.</p>
<p>У мечника 15 хіт-поінтів (життів), пошкодження при атаці 5, шанс ухилятись 60%.<br/>
Лучник: 12 hp, 4 dmg, 40% dodge<br/>
Маг: 8 hp, 10 dmg, 30% dodge<br/>
</p>
<p>В main() створіть два масива (ворогуючі сторони) по три юніта в кожному, причому тип юніта (мечник, лучник чи маг) має задаватись випадково, при заповненні цих масивів. Тобто один раз запустивши вашу програму, може створитись три лучники проти мечника і двох магів, іншого - лучник, мечник і маг проти двох мечників і лучника і т.д.</p>
<p>Далі в циклі земулюйте бій між ними, поки бійці однієї з сторін всі не загинуть. В консоль при цьому виводьте повідомлення хто кого атакував, чи вдалась атака, скільки життя залишилось у жертви чи вона загинула. Нехай бій відбувається поступово, по натиснення клавіші spacebar (пробіла), щоб ми могли спостерігати його атака за атакою.</p>
<p>В кінці бою оголосіть, яка команда перемогла (перша/друга, синя/червона, альянс/орки - як вже ваша фанатзія вам підскаже).</p>

<p>Не забудьте здійснити приведення типів і використати віртуальні функції.</p>
<hr/>
<h3>Урок 21. Файли. Робота з файлами засобами С. Аргументи командного рядка</h3>
  <h5>Завдання 1</h5>
  <p>Створити телефонний довідник, який здійснює наступні операції:
  <ul>
    <li>Додавання абонентів в базу.</li>
    <li>Видалення абонентів з бази.</li>
    <li>Модифікація даних абонента.</li>
    <li>Пошук абонентів по телефонному номеру або прізвищу.</li>
    <li>Друк в алфавітному порядку абонентів з заданого діапазону номерів або прізвищ; наприклад, для номерів діапазону можу бути: 222222 - 333333, а для прізвищ: Іванаускас - Іванов (тобто Іванова в діапазон не входить).</li>
    <li>Можливість збереження знайденої інформації в файл.</li>
    <li>Збереження бази в файл.</li>
    <li>Завантаження бази з файла.</li>
  </ul>
    А також додати до програми можливість видалення та переіменування вказаного користувачем файла.
  </p>
  <h5>Завдання 2</h5>
  <p>Написати програму, яка відкриває текстовий файл, ім'я якого береться з командного рядка. Організувати цикл, який запитує в користувача позицію в файлі, після чого програма повинна роздрукувати частину файла, починаючи з введеної позиції і до наступного символа нового рядка. Цикл закінчується, коли вводиться нечисловий символ.</p>
  <hr/>
<h3>Урок 22. Файли. Файлові потоки введення/виведення</h3>
  <h5>Завдання 1</h5>
  <p>Написати програму, яка виводить статистику по вказаному користувачем файлу в наступному вигляді:
<ul>
<li>кількість коротких слів (який складається максимум з 10 символів);</li>
<li>кількість великих слів;</li>
<li>кількість цифр;</li>
<li>кількість символів пунктуації, наприклад, (!), (,), (.), (-).</li>
</ul>
Крім того, у відповідь на написанення довільної клавіши або на певний пункт меню, здійснити заміну всіх цифр в файлі на символи (*), а додатково (на 12 балів) зробити видалення всіх символів пунктуації.
</p>
  <h5>Завдання 2</h5>
  <p>Написати програму, яка дозволяє записувати в файл інформацію про результати сесії (оцінки) певної групи студентів. Організувати зчитування даної інформації з файлу та підрахунок середнього балу в групі.</p>
<p>Використайте, розроблені в уроці 6 класи Group ("Група") та Student ("Студент"). Додати методи Save() та Read() для запису та зчитування обєктів в/з файла.</p>
<hr/>
<h3>Урок 23. Виключення. Оператор typeid.</h3>
  <h5>Завдання 1</h5>
<p>Модифікуйте правила бою з домашньої роботи "Сутичка" (Урок 20) так, щоб кожен боєць (Воїн, Лучник чи Маг) вишукував серед ворогів суперника свого типу і атакував його. Скажемо, якщо маємо команди:<br />
A11 - M21<br />
A12 - S22<br />
S13 - A23<br />
...то А11 має вибрати своєї ціллю А23.</p>
<p>Якщо ворогів свого типу не знайдено, нехай генерується відповідне повідомлення про помилку та бійці атакують по старим правилам (тим, що ви написали раніше).</p>
  <h5>Завдання 2</h5>
<p>
Передбачте у попередньому домашньому завданні (урок 2, завдання 2), щоб у випадку виникнення помилок (наприклад, при зчитуванні або записі у файл, введенні невірного значення імені студента тощо) генерувались відповідні виключення.</p>
<hr/>
  <h3>Урок 24. STL. Ітератори та контейнери</h3>
  <h5>Завдання 1</h5>
  <p>Написати реалізацію класу stack бібліотеки STL на основі елементів типу double. Основна програма повинна містити код створення об'єкта, після чого потрібно "програти" методи даного класу. Оцінка залежить від повноти реалізації методів даного класу.</p>
  <h5>Завдання 2</h5>
  <p>Написати реалізацію класу queue на основі елементів типу string. Основна програма повинна містити код створення об'єкта, після чого потрібно "програти" методи даного класу. Оцінка залежить від повноти реалізації методів даного класу.</p>
  <h5>Завдання 3</h5>
<p>Написати програму, яка використовує клас string для аналізу рядка, що містить математичний вираз, наприклад, вигляду - (2+3)*4+1. Рядок вводиться з клавіатури. Програма видає результат обрахунку виразу</p>
<hr/>
  <h3>Урок 25. STL. Функтори, алгоритми та адаптери</h3>
  <h5>Завдання 1</h5>
  <p>Створити multimap та multiset на основі елементів типу класу CPerson, що містить в своєму класі наступні обов’язкові поля: ім’я, прізвище, вік, назва посади на підприємстві, назва відділу, в якому працює. Вимоги: обов’язково реалізувати пошук особи по будь-якій з ознак та обов’язковим є наявність меню в програмі. Оцінка залежить від повноти реалізації методів даного класу.</p>
  <h5>Завдання 2</h5>
  <p>Придумати та реалізувати довільний унарний та бінарний функтор.</p>
</lesson>