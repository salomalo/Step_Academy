<?xml version="1.0" encoding="windows-1251" ?>

<!DOCTYPE page [
<!ENTITY nbsp "&#160;">
<!ENTITY пробел "&#160;">
<!ENTITY shy "&#173;">
<!ENTITY перенос "&#173;">
]>

<?xml:stylesheet type="text/xsl" href="../common/layout.xsl" ?>

<Урок xmlns="x-schema:Schema.xml" название="Типы данных в SQL Server." 
предыдущий="section01.xml" следующий="section03.xml" copyright="© 2005 Вадим Волянский, Алексей Туманов.">

<h1 style="color:maroon">Типы данных в SQL Server.</h1>

<h3>Для чего вообще нужны типы данных.</h3>

<p>
Дело все в том, что, создавая таблицу, вы обязаны определить для каждого поля (столбца) его тип данных и имя. Т.е. поле, в котором необходимо хранить, к примеру, имя человека должно быть строковым, а не числовым, а поле для хранения даты никогда не будет денежным. Это сразу же гарантия того, что вместо имени пользователь не введет в поле возраст. Попытка это осуществить выдаст ошибку.
Ведь если вы хотите купить торт, а вам дают рыбу, вы не согласитесь, т.к. это разные "типы данных". Вспомните C++. При создании переменной вы обязательно указывали ее тип данных.
</p>

<h3>Итак, какие же они есть:</h3>

<ol>
	<li>Строковые типы данных.</li>
	<ul>
		<li><b><i>char(кол-во символов)</i></b></li>
	<p>
Например, char(10), определяет, что это строка фиксированной длины, количество символов в которой не может превышать 10. Если вы в этом поле сохраните 1 символ, то на жестком диске все равно будет храниться все поле, размером 10 символов. При попытке сохранить строку большего размера, чем 10 символов, будет ошибка.
	</p>
		<li><b><i>varchar(кол-во символов)</i></b></li>
		<p>
	varchar(10) обозначает, что это строка переменной длины, максимальное кол-во символов в которой не может превышать 10, но если в этом поле сохранить 1 символ, то на жестком диске будет храниться 1 символ. Если же ввести больше символов, чем 10, то это приведет к ошибке при сохранении данных. Т.о. этот тип данных является более экономным, но это отражается на производительности базы данных.
	</p>
	</ul>
<p>Оба эти типа данных имеют ограничение по максимально возможному кол-ву хранимых символов. Оно составляет 8000 символов.</p>
	<li>Целочисленные типы данных.</li>
	<ul>
		<li><b><i>tinyint</i></b></li>
	<p>
Занимает в памяти 1 байт. При этом диапазон значений, который он может в себе сохранить от 0 до 255.
	</p>
		<li><b><i>smallint</i></b></li>
	<p>
Занимает в памяти 2 байта и может сохранять числа от -32767 до +32676.
	</p>
		<li><b><i>int</i></b></li>
	<p>
Занимает в памяти 4 байта и может сохранять числа от -2147483647 до +2147483647.
	</p>
		<li><b><i>bigint</i></b></li>
	<p>
Занимает в памяти 8 байт и может сохранять числа от -9223372036854775808 до +9223372036854775808.
	</p>
	</ul>
<p>
Попытка ввода значений выше либо ниже указанных диапазонов приведет к ошибке, сообщающей о переполнении стека. Данные при этом сохранены не будут.
</p>
	<li>Типы данных для хранения дробных значений.</li>
	<ul>
		<li><b><i>real(кол-во разрядов)</i></b></li>
	<p>
При объявлении поля real(5), в нем можно хранить значения типа 1.2345, 123.45, но общее кол-во разрядов не может превышать кол-во указанное в круглых скобках. Если кол-во разрядов не указать, то по умолчанию ставится значение равное 7-ми. Для этого типа данных 7 - является максимумом.
	</p>
		<li><b><i>float(кол-во разрядов)</i></b></li>
	<p>
float указывается для определения количества разрядов больше 7-ми. Если кол-во разрядов не указать, то по умолчанию будет 15. Если указать кол-во разрядов меньше чем 8, то float автоматически меняется на real.
	</p>

	<li><b><i>numeric(общее кол-во разрядов, сколько из них отводится под дробную часть)</i></b></li>
	<p>
Если кол-во разрядов не указать, то они берутся как 18 и 0. Общее кол-во указать как 0 нельзя. Превышение кол-ва разрядов дробной части над общей также приведет к ошибке. Если указать тип поля как numeric(10,2), это будет определять, что можно сохранять числа, у которых часть до запятой (мантисса) не превышает 8 разрядов, а дробная двух. Если кол-во разрядов после запятой больше чем указанное, то при сохранении будет произведено математическое сокращение. Если же кол-во разрядов числа до запятой превышает указанный размер, то это приведет к ошибке при сохранении данных (данные при этом не сохранятся).
	</p>
	<li><b><i>decimal(общее кол-во разрядов, сколько из них отводится под дробную часть)</i></b></li>
	<p>
Полный аналог numeric.
	</p>
	</ul>
	<li>Типы данных для хранения даты и времени.</li>
	<ul>
	<li><b><i>smalldatetime</i></b></li>
	<p>
Поле в котором могут храниться даты от 1900.01.01 до 2079.06.06. 
	</p>
	<p>
Даты должны быть представлены в виде Год-Месяц-День Часы:Минуты:Секунды. Если секунды указать, то общая дата будет сокращена, относительно указанного кол-ва. Например, если сохранить дату '2002.12.05 23:59:59', то сохранена она будет как '2002-12-06 00:00:00'. Если же секунд будет меньше 30, то сокращение производиться не будет.

	</p>
		<li><b><i>datetime</i></b></li>
	<p>
Поле в котором могут храниться даты от 1753.1.01 до 9999.12.03. 
	</p>
	<p>
Даты должны быть представлены в виде Год-Месяц-День Часы:Минуты:Секунды.Милисекунды. В поле с таким типом данных также будет производится сокращение при вводе кол-ва миллисекунд 999.
	</p>
	</ul>
	<li>Типы данных для хранения чисел в денежном представлении.</li>
	<ul>
	<li><b><i>smallmoney</i></b></li>
	<p>
Диапазон значений, который можно сохранить в этом поле от -214748.3647 до +214748,3647. Занимает 4 байта.
	</p>
	<li><b><i>money</i></b></li>
	<p>
Диапазон значений этого типа данных от -922337203685477.5808 до +922337203685477.5808. Занимает 8 байт.
	</p>
	</ul>
	<li>Битовые типы данных.</li>
	<ul>
	<li><b><i>binary(кол-во требуемых байт)</i></b></li>
	<li><b><i>varbinary(кол-во требуемых байт)</i></b></li>
<p>
Оба эти типа данных служат для хранения информации в двоичной системе исчисления. Как и в строковых типах данных кол-во требуемых байт не может превышать 8000. При использовании битовых (как и строковых) типов данных необходимо помнить, что превысить кол-во указанных байт нельзя. При попытке ввести больше значений, чем указано в кол-ве элементов приведет к ошибке!!!  Данные сохранены не будут.
</p>
	</ul>
	<li>Дополнительные типы данных.</li>
	<ul>
	<li><b><i>bit</i></b></li>
<p>
Этот тип данных необходим для сохранения всего двух значений - истина либо ложь. Учитывая, что этот тип данных занимает в памяти 1 бит, хранить в себе он может либо 0 (ложь) либо 1 (истина). Если в одной таблице существует несколько столбцов, объявленных с типом данных bit, то они будут объединены в группы из 8-ми столбцов в каждой, т.е. суммарно по 1 байту.
</p>
	<li><b><i>text</i></b> и <b><i>image</i></b></li>
<p>
Оба эти типа данных относятся к т.н. группе типов данных blob (Binary Large Object - Большой объект в двоичном формате). Они позволяют сохранять информацию размером до 2 Гб. Однако использование этих типов данных очень сказываются на производительности, т.к. требуется очень много времени для их обработки. При возможности стараются в базе данных сохранять путь к требуемому объекту, а не сам объект. Но если на первом месте безопасность данных, то делать это не рекомендуется.
</p>
	</ul>
	<li>Типы данных Unicode.</li>
<p>
Unicode представляет тип символов, при котором для хранения одного символа используется не один байт, а два. Это необходимо при использовании, например записей на китайском, японском и пр. языках, у которых в алфавите символов больше чем 256. 
</p>
	<ul>
		<li><b><i>nchar(кол-во символов), nvarchar(кол-во символов)</i></b></li>
		<p>
		По принципу использования они ничем не отличаются от char и varchar, но у этих типов данных максимальное кол-во требуемых байт не может превышать 8000. Т.о. максимальное кол-во символов, которые можно туда записать - 4000.
		</p>
		<li><b><i>ntext</i></b></li>
		<p>
		То же, что и text, но кол-во символов, помещаемых в 2Гб меньше в 2 раза (опять же за счет размера одного символа).
		</p>
	</ul>
	<li>Автоматически обновляемые типы данных.</li>
	<ul>
		<li><b><i>rowversion (старое название timestamp)</i></b></li>
	</ul>
	<p>
	Существует возможность для определенного поля задать тип данных, определяющий, что значения в это поле будут автоматически записываться при добавлении данных в таблицу. Эти значения представляют собой набор автоматически генерируемых чисел в двоичном формате. Эти значения удобно использовать как информацию о порядке сохранения записей в таблицы текущей базы данных, т.к. в пределах одной базы данных значения в этих полях повторяться не будут. Такими типами данных являются timestamp и rowversion. (Эти поля не отвечают за хранение даты!!!) Занимает этот тип данных 8 байт.
	</p>

	<li>Собственные типы данных.</li>
	
<p>
В SQL Server существует возможность создавать собственные типы данных. Это позволяет дать набору настроек одно имя и использовать его в дальнейшем. Все собственные типы данных будут базироваться на базовых. В SQL Server собственные типы данных называются <b>домены</b>. Создавая собственный тип необходимо обратить внимание на то, в какой базе данных вы находитесь в момент создания. К примеру, создав собственный тип в базе данных Test1, использовать его вы можете только в ней. Если же вам требуется тип данных, который можно использовать во всех базах данных, которые будут созданы в будущем необходимо собственный тип данных определить один раз в базе данных model, т.к. все создаваемые базы данных являются копией базы данных model. Но в тех базах, которые в текущий момент уже созданы, новые типы данных существовать не будут.
</p>

<p>
Существует два способа их создания: через утилиты и через запрос.
</p>
<h2 align="center"><font color="#04BC30">Через Enterprise Manager.</font></h2>
<ul style="list-style-image:url(img/marker1.jpg); list-style-type: square;">
	<li>Запускаете Enterprise manager и выбираете нужную базу данных.</li>
	<p>Нажимаете правой кнопкой на User Defined Datatypes и выбираете New User Data Type (создать новый пользовательский тип данных).</p>
	<img src="img/pict1.jpg"></img>

<p>
Вы увидите следующее окошко:
</p>
</ul>
<p>
<img src="img/pict2.jpg" style="float:right; margin-right:20px;"></img>
В поле Name необходимо ввести имя для создаваемого типа данных. В выпадающем списке Data type, находящемся ниже, необходимо указать какой стандартный тип будет подставляться на то место, где будет указываться созданный тип. Поле Length активно только в том случае, если для указанного типа данных существует возможность задать размер. Например, вы можете выбрать тип данных varchar, задать ему длину 25. Имя этому типу данных дать MyType1. При создании таблицы, если вы укажете тип поля MyType1, то оно автоматически станет varchar(25).
</p>

<p>
Поле Allow NULLs. NULL - это пустота. Если не поставить галочку в этом пункте, то поле этого типа данных не сможет быть пропущено при занесении данных в таблицу. Этот параметр можно будет переопределить при создании таблицы.
</p>
<br/>
<p>
	Для <b>удаления</b> пользовательского типа данных необходимо в Enterprise manager открыть папку User Defined Data Types и в контекстном меню требуемого типа данных выбрать "Удалить". 
</p>
<p>
В появившемся окне:
</p>
<img src="img/pict4.jpg" style="float:none;"></img>
<p>
необходимо выбрать Drop All, тем самым, удалив ранее созданный тип данных.
</p>
<h2 align="center"><font color="#04BC30">Через запрос.</font></h2>

<ul style="list-style-image:url(img/marker1.jpg); list-style-type: square;">
<li>Запускаете Query Analizer.</li>
</ul>

<p>
<img src="img/pict3.jpg"></img>
</p>
<p>
Необходимо вызвать процедуру по имени sp_addtype. Для вызова хранимой процедуры используется ключевое слово Exec, либо Execute.
</p>
<pre>
EXEC sp_addtype имя_нового_типа_данных базовый_тип, дополнительные_параметры;
</pre>

<p>Пример.</p>

<pre>
Execute sp_addtype MyString varchar(25) not null;
</pre>

<p>
Тем самым будет создан собственный тип данных с именем MyString, представляющий из себя строку varchar длиной 25 символов и столбец этого типа данных не может быть пустым (пропуск записи значения в это поле приведет к ошибке), если только при создании таблицы не переопределить этот параметр.
</p>

<p>
Хранимая процедура sp_droptype <b>удаляет</b> пользовательский тип данных.
</p>

<pre>
Execute sp_droptype MyString;
</pre>

<p>
Удалить пользовательский тип данных можно только если ни в одной таблице текущей базы данных он не был использован.
</p>

</ol>

<p></p>


</Урок>