<?xml version="1.0" encoding="windows-1251" ?>

<!DOCTYPE page [
<!ENTITY nbsp "&#160;">
<!ENTITY пробел "&#160;">
<!ENTITY shy "&#173;">
<!ENTITY перенос "&#173;">
]>

<?xml:stylesheet type="text/xsl" href="../common/layout.xsl" ?>

<Урок xmlns="x-schema:Schema.xml" название="Внешние ключи. Связи. Целостность данных." 
предыдущий="section01.xml" следующий="section03.xml" copyright="© 2005 Вадим Волянский, Алексей Туманов.">

<h1 style="color:maroon">Внешние ключи. Связи. Целостность данных.</h1>

<p>
Вы увидели возможные варианты ошибок при проектировании баз данных и учли, что однотабличная база данных - это плохо. Поэтому, давайте разбираться с созданием многотабличных баз данных. Но нужно не забывать, что, хоть информация и разделяется на несколько таблиц, необходимо определить, как они должны взаимодействовать между собой. Для этого необходимо определить несколько ключевых понятий.
</p>

<h2 align='center'><font color="#9D0064">Первичный ключ.</font></h2>

<p>
<b>Первичный ключ</b> - это поле таблицы, которое служит для идентификации строк. Самый лучший пример первичного ключа - это нумерация строк в игре морской бой. Представьте, какая была бы путаница, если бы на поле для игры в морской бой было бы 2 строки с номером 3, 4 строки с номером 5 и т.д. Тогда точно идентифицировать строку просто невозможно.
</p>

<p>
В реальной жизни может возникнуть ситуация, когда в базе данных, которая хранит информацию о людях, появится несколько человек с одинаковыми именами и фамилиями. В этой ситуации однозначно идентифицировать человека нельзя, поэтому единственный выход - создать поле, в котором будут храниться неповторяющиеся номера строк, и по этому полю определять требуемую строку.
</p>

<img src="img\pict23.jpg"></img>

<p>
Т.о. столбцы идентифицируются по имени столбца (если вы помните, то в одной таблице имена столбцов также не могут повторяться), а стоки идентифицируются по первичному ключу. Обычно этому полю дают имя Id. Таким полем обязана обладать любая таблица реляционной базы данных.
</p>

<p>
Для установки первичного ключа необходимо при создании таблицы, в контекстном меню к полю, выбрать пункт меню Set Primary Key.
</p>

<img src="img\pict1.jpg"></img>

<p>
Заметьте, что тип данных у поля установлен int, а дополнительный параметр - Identity: Yes, Identity Seed: 1, Identity Increment: 1. (Если вы забыли - Identity это счетчик). Для первичного ключа это незаменимая опция, т.к. при добавлении информации вы вряд ли будете помнить, какой уникальный номер был в последнем добавленном элементе, а так каждое последующее значение будет на 1 больше чем предыдущее.
</p>

<h3 align='center'><font color="#1925AB">Составной первичный ключ.</font></h3>

<p>
Существует возможность создать таблицу, у которой первичный ключ будет основываться одновременно на нескольких полях. Тогда уникальным будет не значение в каждом из них, а <b><i>уникальны будут сочетания значений этих полей</i></b>.
</p>

<p>
Рассмотрим таблицу, хранящую информацию о проектах и людях, которые их реализуют.
</p>

<img src="img\pict25.jpg"></img>

<p>
Первых два поля определяют составной первичный ключ. Т.е. любой человек может участвовать в любом проекте, либо во всех сразу. Составной первичный ключ, при этом, будет обеспечивать проверку, чтобы ни один человек не участвовал 2 раза в одном проекте. Это возможно за счет того, что одинаковых комбинаций первого и второго поля невозможны.
</p>

<p>
Чтобы создать составной первичный ключ есть 2 способа. Один из них - при помощи запроса, мы рассмотрим в одном из следующих уроков. Пока остановимся на его определении при помощи Enterprise Manager.
</p>

<img src="img\pict26.jpg"></img>

<p>
Все что нужно сделать - при создании таблицы выделить те поля, которые вы хотите включить в составной первичный ключ, после чего выбрать в контекстном меню к выделенным полям Set Primary Key. <b>Важно</b> помнить, что все поля, которые включаются в составной первичный ключ, должны быть обязательными для заполнения (не должна стоять галочка Allow Nulls).
</p>

<h2 align='center'><font color="#9D0064">Внешний ключ.</font></h2>

<p>
<b>Внешним ключом</b> называется поле, в котором хранятся значения первичного ключа другой таблицы.
</p>

<p>
Давайте рассмотрим хранение информации в базе данных books. Если вы заметили, то поле Izd хранит издательства и при этом названия издательств повторяются. Происходит следующее. Учитывая, что тип данных поля Izd nvarchar(255), а самое короткое имя у издательства "Век", то минимальное кол-во занимаемых одной строкой байт - 6 (а максимальное теоретически 500 байт).
</p>

<p>
Чтобы избежать такого перенасыщения таблицы повторяющейся информацией, обычно создают отдельную таблицу, хранящую список издательств без повторений. В основной таблице, при этом, добавляется поле, в которое помещают значения первичного ключа из таблицы с издательствами. Список издательств с основной таблицы, после этого удаляется.
</p>

<p>
Получается, что таблица books
</p>

<img src="img\pict2.jpg"></img>

<p>
преобразуется в несколько таблиц.
</p>

<img src="img\pict3.jpg"></img>

<p>
Единицей обычно обозначают первичный ключ, а знаком бесконечность - внешний ключ.
</p>

<p>
Не сложно догадаться, что желательно еще отдельно вынести тематики и категории.
</p>

<p>
Еще один пример.
</p>

<p align="justify">
Допустим, что у нас есть две таблицы в базе данных: первая таблица содержит данные о продавцах, а вторая - о 
покупателях. В таблице с данными о покупателях есть столбец, в котором записано имя продавца, продавшего товар.
Было бы очень скучно и непродуктивно писать по несколько раз одно и то же имя продавца (а что делать, если есть 
только 2-3 продавца, а сделок осуществлено более 1000 ?). Вот тут и возникает вопрос: может существует другая, 
более удобная возможность заполнения данного поля?
</p>

<TABLE BORDER="1">Продавцы
	<TR>
		<TD>ID</TD>
		<TD>Name</TD>
	</TR>
	<TR>
		<TD>1</TD>
		<TD>Brown</TD>
	</TR>
	<TR>
		<TD>2</TD>
		<TD>Smith</TD>
	</TR>
</TABLE>
<TABLE BORDER="1">Покупатели
	<TR>
		<TD>ID</TD>
		<TD>Name</TD>
	</TR>
	<TR>
		<TD>1</TD>
		<TD>Gates</TD>
	</TR>
	<TR>
		<TD>2</TD>
		<TD>Jackson</TD>
	</TR>
</TABLE>
<TABLE BORDER="1">Сделки
	<TR>
		<TD>ID</TD>
		<TD>ID_cust</TD>
		<TD>ID_sal</TD>
		<TD>Amt</TD>
	</TR>
	<TR>
		<TD>1</TD>
		<TD>2</TD>
		<TD>2</TD>
		<TD>300</TD>
	</TR>
	<TR>
		<TD>2</TD>
		<TD>1</TD>
		<TD>2</TD>
		<TD>500</TD>
	</TR>
</TABLE>
<p align="justify">В данном случае ID_cust и ID_sal в таблице "сделки" являются внешними ключами 
которые соответствуют первичным ключам в таблице "покупатели"(ключевое поле ID) и в таблице 
"продавцы"(ключевое поле также ID). </p>

<h2 align='center'><font color="#9D0064">Связи.</font></h2>

<p>
Чтобы суметь нормально спроектировать базу данных нужно понять, что информация, хранящаяся в нескольких таблицах одной базы данных, все равно остается неразрывным целым. В связи с этим нужно рассмотреть типы взаимозависимости информации в таблицах - сокращенно связи.
</p>

<h3 style="COLOR: maroon">Типы связи.</h3>
<P align="justify">Между двумя сущностям, например, А и В возможны четыре вида 
связей.</P>
<P align="justify"><B>Первый тип</B> – связь ОДИН-К-ОДНОМУ (1:1): в каждый момент 
времени каждому представителю (экземпляру) сущности А соответствует 1 или 0 
представителей сущности В:</P>
<P align="center"><IMG height="26" src="img/pic2-2-1.gif" width="298"></IMG></P>
<P align="justify">Студент может не "заработать" стипендию, получить обычную или 
одну из повышенных стипендий.</P>
<P align="justify"><B>Второй тип</B> – связь ОДИН-КО-МНОГИМ (1:М): одному 
представителю сущности А соответствуют 0, 1 или несколько представителей 
сущности В.</P>
<P align="center"><IMG height="30" src="img/pic2-2-2.gif" width="299"></IMG></P>
<P align="justify">Квартира может пустовать, в ней может жить один или несколько 
жильцов.</P>
<P align="justify">Так как между двумя сущностями возможны связи в обоих 
направлениях, то существует еще два типа связи МНОГИЕ-К-ОДНОМУ (М:1) и 
МНОГИЕ-КО-МНОГИМ (М:N).</P>
<P align="justify"><B>Пример.</B> Если связь между сущностями МУЖЧИНЫ и 
ЖЕНЩИНЫ называется БРАК, то существует четыре возможных представления такой 
связи:</P>
<P align="center"><IMG height="123" src="img/pic2-2-3.gif" width="284"></IMG></P>
<P align="justify">Существует еще один вид связей, так называемая "связь предок/потомок".
Если первичный ключ данной таблицы присутствует в поле (полях) одной или нескольких таблиц,
то эти таблицы являются "потомками" по отношению к данной таблице, а она в свою очередь 
является "предком" по отношению к ним.</P>
<br/><br/>
<p>
Переходим к практике создания многотабличных баз дынных. 
</p>

</Урок>