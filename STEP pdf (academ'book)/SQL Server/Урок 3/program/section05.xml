<?xml version="1.0" encoding="windows-1251" ?>

<!DOCTYPE page [
<!ENTITY nbsp "&#160;">
<!ENTITY пробел "&#160;">
<!ENTITY shy "&#173;">
<!ENTITY перенос "&#173;">
]>

<?xml:stylesheet type="text/xsl" href="../common/layout.xsl" ?>

<Урок xmlns="x-schema:Schema.xml" название="Многотабличные запросы." 
предыдущий="section04.xml" следующий="HomeTask.xml" copyright="© 2005 Вадим Волянский, Алексей Туманов.">
<h1 style="color=maroon">Многотабличные запросы.</h1>

<p>
Надеюсь, вы поняли, как создавать многотабличные базы данных и понимаете их преимущества. Но, вполне вероятно, с информацией, которая в них храниться, нужно научиться работать как с одним целым.
</p>

<p>
Предположим, что у вас есть 3 таблицы и в каждой из ним есть поле Name. При этом нужно вывести одновременно информацию по всем трем полям. Поймет ли SQL Server, что Name нужно брать из 3-х таблиц, да и еще в определенном порядке. Конечно же, нет. Поэтому для обращения к полям в многотабличных запросах используется обращение по полному имени: "<b>Имя_таблицы.имя_поля</b>"
</p>

<p>
Для начала давайте рассмотрим типичную ошибку при написании запросов. Нужно вычитать названия книг (из таблицы Books) и их тематик (таблица Themes). Теоретически этот запрос будет выглядеть следующим образом:
</p>

<pre style="border-color:#FF0000; color=#FF0000">
ОШИБКА!!!

Select Books.name, Themes.name

from books, themes
</pre>

<img src="img\pict20.jpg"></img>

<p>
На экране появятся записи, но получится, что каждая книга есть во всех тематиках. Это наглядный пример т.н. Декартового произведения двух таблиц. Это всевозможные комбинации строк первой и второй таблицы.
</p>

<p>
Рассмотрим Декартово произведение на меньшей базе данных.
</p>

<img src="img\pict33.jpg"></img>

<p>
В этой базе данных есть две таблицы. Одна содержит информацию о сотрудниках, вторая об отделах, в которых они работают. Если сделать запрос типа:
</p>

<pre>

select workers.name,departments.name from workers,departments

</pre>

<p>
Получится такой результат:
</p>

<img src="img\pict34.jpg"></img>

<p>
Т.е. каждый сотрудник есть в каждом отделе. Чтобы этого не было нужно указать связь между первичным ключом таблицы Departments и внешним ключом таблицы Workers. Запрос примет вид:
</p>

<pre>

select workers.name,departments.name from workers,departments

where workers.id_dep=departments.id

</pre>

<p>
Вот что будет в результате:
</p>

<img src="img\pict35.jpg"></img>

<p>
Чтобы не допускать больше таких ошибок, давайте сразу определим набор правил.
</p>

<p>При написании многотабличных запросов нужно:</p>

<ol>
	<li>К именам полей обращаться по полному имени</li>
	<li>Чтобы не было Декартового произведения необходимо указывать связь между используемыми таблицами. Для этого добавляется в запрос ключевое слово Where, после чего указывается <b>Имя_таблицы.Первичный_ключ=Имя_таблицы2.Внешний_ключ</b>. И такие связи должны быть указаны для все таблиц, которые указываются в запросе.</li>
</ol>

<p>
Общий синтаксис:
</p>

<pre style="border-color:#FF0000">
Select имя_таблицы1.имя_поля, имя_таблицы2.имя_поля ... имя_таблицыN.имя_поля


From имя_таблицы1, имя_таблицы2, имя_таблицыN


Where имя_таблицы1.внешний_ключ=имя_таблицы2.первичный_ключ And 


имя_таблицы1.внешний_ключ=имя_таблицыN.первичный_ключ


And дополнительные_условия
</pre>

<p>
Связи первичного и внешнего ключа нужно определять по диаграмме. В примере они указаны для наглядности.
</p>

<p>
Возвращаемся к примеру. Нужно показать названия книг и название тематики.
</p>

<pre style="border-color:#FF0000; color=#FF0000">
Правильно!!!

Select Books.name, Themes.name

from books, Themes

where books.id_press=themes.id
</pre>

<img src="img\pict21.jpg"></img>

<p>
Пример 2.Нужно показать всю информацию о книгах издательства BHV.
</p>

<pre>
Select Books.new, Books.name, Press.name, Books.price, Books.pages, Themes.name, Categories.name


from books, themes, categories, press


where books.id_theme=themes.id and books.id_category=categories.id and books.id_press=press.id


and press.name like '%BHV%'
</pre>
<img src="img\pict22.jpg"></img>

</Урок>