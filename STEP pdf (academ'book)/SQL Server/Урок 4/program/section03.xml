<?xml version="1.0" encoding="windows-1251" ?>

<!DOCTYPE page [
<!ENTITY nbsp "&#160;">
<!ENTITY пробел "&#160;">
<!ENTITY shy "&#173;">
<!ENTITY перенос "&#173;">
]>

<?xml:stylesheet type="text/xsl" href="../common/layout.xsl" ?>

<Урок xmlns="x-schema:Schema.xml" название="GROUP BY и HAVING." 
предыдущий="section02.xml" следующий="section04.xml" copyright="© 2005 Вадим Волянский, Алексей Туманов.">

<h1 style="color:maroon">GROUP BY и HAVING.</h1>

<p>
Смысл написания всех запросов на выборку сводится к группировке хранящихся данных так, чтобы их было удобно читать. В результате запросов мы получаем конкретно интересующую нас информацию в отсортированном виде. Функции агрегирования помогают подсчитать все в  общем из базы, а что делать, если результат должен быть не общий (единое значение, которое возвращает функция агрегирования), а разделен по определенному критерию (например цена самой дешевой книги по каждому из издательств). Вот здесь нам на помощь и приходят ключевые слова Group By и Having.
</p>

<p>
При попытке рядом с функцией агрегирования указать какой-либо столбец приводит к ошибке!!! Давайте выясним причину этого. Функция агрегирования возвращает одно значение, например сумму всех страниц, а в столбце, который указывается рядом - сколько угодно значений. Конечно же SQL Server не сможет адекватно отобразить результат такого запроса, т.к. он не несет никакой смысловой нагрузки. Чтобы в этом был смысл и обработка такого запроса не приводила к ошибке используется ключевое слово GROUP BY.
</p>

<p>
Group by позволяет разбить общий результат, который возвращает функция агрегирования, по определенному критерию (сгруппировать данные по критерию). Общий синтаксис:
</p>

<pre style="border-color=#FF0000">

Select агрегатная_функция, поле1, поле2,...полеN

From имя_таблицы

Where условие

Group by поле1, поле2,...полеN

</pre>

<p>
Критерием будет являться то поле, которое указывается рядом с агрегатной функцией. Не забывайте, что после Group by должны указываться все поля, которые стоят рядом с функцией агрегирования. В противном случае это приведет к ошибке.
</p>

<p>
Пример. Нужно вывести на экран кол-во книг по каждому из издательств (таблица Books).
</p>

<p>
Для нахожления общего кол-ва запрос будет такой
</p>

<pre style="border-color=#A65A00">

select count(id) as "Общее кол-во" from books

</pre>

<p>
Результат: 
</p>

<img src="img\pict8.jpg"></img>

<p>
Необходимо полученный результат разбить по издательствам:
</p>


<pre style="border-color=#A65A00">

Select count(books.id)as "Кол-во", press.name

From books,press

Where books.id_press=press.id

Group by press.name

Order by 1 desc

</pre>

<p>
Результат: 
</p>

<img src="img\pict9.jpg"></img>

<p>
Пример2. Показать кол-во книг, взятых каждой из групп студентов. (база данных library).
</p>

<pre style="border-color=#A65A00">

Select count(s_cards.id_book) as "Кол-во взятых книг",groups.name as "Название группы"

From groups,students,s_cards

where groups.id=students.id_group and students.id=s_cards.id_student

group by groups.name

</pre>

<img src="img\pict10.jpg"></img>

<p>
Как видно, общее кол-во, которое вернулось из ф-ции count разделено по критерию groups.name (название группы).
</p>

<p>
Иногда нужно указывать рядом с функцией агрегирования несколько полей. Тогда после Group by нужно указывать все перечисленные в запросе поля.
</p>

<p>
Пример3. Показать кол-во книг, взятых каждым студентом, группу, имя студента и фамилию.
</p>

<pre style="border-color=#A65A00">

Select count(s_cards.id_book) as "Кол-во", groups.name as "Группа", students.firstname, students.lastname

From groups,students,s_cards

Where groups.id=students.id_group and students.id=s_cards.id_student

Group by groups.name,students.firstname,students.lastname

</pre>

<img src="img\pict11.jpg"></img>

<p>
Важно помнить, что после Group by нельзя указывать поле, которого нет в перечислении для вывода на экран.
</p>

<h3 align='center'><font color="#1925AB">Директива Having.</font></h3>

<p>
Директива Having служит для наложения условия на поле, которое указывается в группировке.
</p>

<pre style="border-color=#FF0000">

Select агрегатная_функция, поле1, поле2,...полеN

From имя_таблицы

Where условие

Group by поле1, поле2,...полеN

Having {[условие_по_агрегатной_функции]либо[условие_по_сгруппированному_полю]}

</pre>

<p>
Условие по сгруппированному полю либо по агрегатной функции указать можно <b>только</b> в директиве Having.
</p>

<p>
Пример1. Показать на экран среднее кол-во страниц по каждой из тематик, при этом показать только тематики, у которых среднее кол-во больше 400.
</p>

<pre style="border-color=#A65A00">

Select avg(books.pages) as "Средняя сумма страниц", themes.name

from books,themes

where books.id_themes=themes.id

group by themes.name

having avg(books.pages)>400

</pre>

<p>
Результат:
</p>

<img src="img\pict12.jpg"></img>

<p>
Пример2. Показать на экран сумму страниц по каждой из тематик, при этом учитывать только книги с кол-вом страниц больше 300.
</p>

<pre style="border-color=#A65A00">

Select sum(books.pages) as "Сумма", themes.name

From books,themes

Where books.id_themes=themes.id and books.pages&gt;300

Group by themes.name

</pre>

<p>
Результат:
</p>

<img src="img\pict13.jpg"></img>

<p>
Как видите, books.pages не участвует в группировке, и поэтому оно указывается в Where. <b>Указать имя поля, которое не участвует в группировке, после директивы Having нельзя!!!</b>
</p>

<p>
Пример3. Показать на экран сумму страниц по каждой из тематик, при этом учитывать только книги с кол-вом страниц больше 300, но учитывать, при этом, только тематики 'Программирование', 'Сети' и 'Web-дизайн'.
</p>

<pre style="border-color=#A65A00">

Select sum(books.pages) as "Сумма", themes.name

From books,themes

Where books.id_themes=themes.id and books.pages>300

Group by themes.name

Having themes.name in ('Программирование','Сети','Web-дизайн')

</pre>

<p>
Результат:
</p>

<img src="img\pict14.jpg"></img>

</Урок>