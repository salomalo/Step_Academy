<?xml version="1.0" encoding="windows-1251" ?>

<!DOCTYPE page [
<!ENTITY nbsp "&#160;">
<!ENTITY пробел "&#160;">
<!ENTITY shy "&#173;">
<!ENTITY перенос "&#173;">
]>

<?xml:stylesheet type="text/xsl" href="../common/layout.xsl" ?>

<Урок xmlns="x-schema:Schema.xml" название="Управление правами доступа."  предыдущий="section04.xml" следующий="Hometask.xml" copyright="© 2005 Вадим Волянский, Алексей Туманов.">

<h1 style="color:maroon">Управление правами доступа.</h1>

<p>
До сих пор вы учились, как создавать роли, их преимущества, мощь и пр. Все это время говорилось о том, какие права предоставляют роли. Теперь мы с вами разберем, как настраивать эти права для отдельно взятых пользователей и для группы в целом.
</p>

<p>
Все права доступа можно разделить на такие категории:
</p>

<ol>
	<li>Специальные права доступа.</li>
	<li>Объектные права доступа.</li>
	<li>Командные права доступа.</li>
</ol>

<h3 align="center" style="color:#0E0076">Специальные права доступа.</h3>

<p>
Это права, которые заранее определены ролями на уровне сервера.
</p>

<p>
Например, пользователи, входящие в состав группы dbcreator имеют специальные права доступа, т.к. являются создателями базы данных.
</p>

<p>
Все остальные права, которые есть - это права пользователей.
</p>

<h3 align="center" style="color:#0E0076">Объектные права доступа.</h3>

<p>
Это права, которые представляют совокупность прав по управлению объектами базы данных. Объектом базы данных являются таблицы, представления, хранимые процедуры и пр. Указывая право доступа, необходимо четко указывать объект, для которого это право выдается.
</p>

<p>
К объектным правам доступа относятся:
</p>

<ul>
	<li>Select</li>
	<li>Insert</li>
	<li>Update</li>
	<li>Delete</li>
	<li>References</li>
	<li>Execute</li>
</ul>

<p>
Общий синтаксис раздачи таких прав доступа:
</p>

<pre style="border-color:#FF0000">

<b>Grant</b> {ALL [PRIVILEGES] | разрешение1, разрешение2... разрешениеN}

{

[имя_поля1, имя_поля2... имя_поляN]

ON {имя_таблицы | имя_представления}

| ON {имя_таблицы | имя_представления} [(имя_поля1, имя_поля2... имя_поляN)]

| ON {имя_хранимой_процедуры}

| ON {имя_пользовательской_функции}

}

TO имя_учетной_записи1, имя_учетной_записи2... имя_учетной_записиN

[With grant option]

</pre>

<ol>
	<li>All - определяет, что будут предоставляться все права, которые существуют у указанного объекта.</li>
	<li>PRIVILEGES - ключевое слово, которое определяет, что после него указано перечисление предоставляемых прав доступа. Осталось для совместимости с ранними версиями.</li>
	<li><i>перечисление_разрешений</i>. Здесь перечисляются операторы, при помощи которых будет существовать доступ, к указанным ниже объектам. Например Select, Delete, Execute.</li>
	<li><i>перечисление_полей</i>. Это поля, доступ к которым предоставляется.</li>
	<li><i>Имя_таблицы</i> - это имя таблицы, к которой предоставляется доступ. (аналогично для представления, хранимой процедуры и функции).</li>
	<li>TO - определяет список имен пользователей, либо ролей, на которые распространяются указанные выше права доступа.</li>
	<li>With grant option - определяет, что перечисленные выше пользователи смогут предоставленные им права раздавать другим пользователям. <b>Но только если это будет разрешено командными правами доступа для пользователя.</b></li>
</ol>

<p>
Например, чтобы раздать право на вычитку и обновление информации пользователю test_user для таблицы books базы данных library, необходимо использовать следующий синтаксис:
</p>

<pre>

Grant Select, Update ON books TO test_user

</pre>

<p>
Этот запрос определяет, что пользователь test_user получает право производить запросы Select и Update по отношению к базе данных books.
</p>

<p>
Для раздачи права на добавление информации определенной роли, используется та же хранимая процедура.
</p>

<pre>

Grant Insert ON books TO test_role

</pre>

<p>
<b>ВНИМАНИЕ!!!</b> После этого запроса, все пользователи, включенные в роль test_role, получают право на добавление информации в таблицу books базы данных library. В том числе пользователь test_user.
</p>

<p>
Чтобы аннулировать право доступа используется ключевое слово <b>REVOKE</b>.
</p>

<pre style="border-color:#FF0000">

REVOKE [GRANT OPTION FOR]

{ALL [PRIVILEGES] | право1, право2... правоN }

{

[имя_поля1, имя_поля2... имя_поляN]

ON {имя_таблицы | имя_представления}

| ON {имя_таблицы | имя_представления} [(имя_поля1, имя_поля2... имя_поляN)]

| ON {имя_хранимой_процедуры}

| ON {имя_пользовательской_функции}

}

FROM имя_учетной_записи1, имя_учетной_записи2... имя_учетной_записиN

[CASCADE]

</pre>

<ol>
	<li>Grant option for - определяет, что с пользователя, либо роли снимается право на передачу определенных прав другим пользователям.</li>
	<li>All - определяет, что аннулируются все права, которые существуют у указанного объекта.</li>
	<li>PRIVILEGES - ключевое слово, которое определяет, что после него указано перечисление прав доступа, которые снимаются. Осталось для совместимости с ранними версиями.</li>
	<li><i>перечисление_прав</i>. Здесь перечисляется список объектных прав, которые аннулируются.</li>
	<li><i>перечисление_полей</i>. Это поля, доступ к которым закрывается.</li>
	<li><i>Имя_таблицы</i> - это имя таблицы, с которой снимаются права доступа. (аналогично для представления, хранимой процедуры и функции).</li>
	<li>FROM - определяет список имен пользователей, либо имен ролей, для которых аннулируются указанные выше права доступа.</li>
	<li>CASCADE - определяет, что доступ анулируется не только для указанного пользователя, но и для тех, кому эти пользователи раздавали права.</li>
</ol>

<p>
Теперь снимем с пользователя test_user право на обновление.
</p>

<pre>

Revoke Update ON books From test_user

</pre>

<p>
После этого test_user будет не в праве обновлять информацию, хранимую в таблице books.
</p>

<p>
Но бывает еще один случай. Вы даете права определенной роли. Мы уже определили, что все входящие в нее пользователи, автоматически получают их (для этого роли и служат). А что делать, если для определенного пользователя должно действовать все, кроме определенного права. Именно в этом случае и поможет <b>Отказ в предоставлении объектных прав доступа</b>. Для этого используется ключевое слово Deny.
</p>

<pre style="border-color:#FF0000">

DENY {ALL [PRIVILEGES] | разрешение1, разрешение2... разрешениеN}

{

[имя_поля1, имя_поля2... имя_поляN]

ON {имя_таблицы | имя_представления}

| ON {имя_таблицы | имя_представления} [(имя_поля1, имя_поля2... имя_поляN)]

| ON {имя_хранимой_процедуры}

| ON {имя_пользовательской_функции}

}

TO имя_учетной_записи1, имя_учетной_записи2... имя_учетной_записиN

[CASCADE]

</pre>

<p>
Например, запретим право на добавление пользователю test_user.
</p>

<pre>

Deny Insert On books To test_user

</pre>

<p>
После этого запроса, пользователь test_user не сможет добавлять информацию в books, но на остальных членов роли test_role это не повлияет.
</p>

<p>
<b>ВНИМАНИЕ!!!</b> Не важно, как пользователь получил право, через роль или оно было предоставлено ему напрямую. Запрос Deny, в любом случае, дезактивирует указанные в списке права.
</p>

<h3 align="center" style="color:#0E0076">Командные права доступа.</h3>

<p>К командным правам доступа относятся права типа:</p>

<ol>
	<li>CREATE DATABASE</li>
	<li>CREATE DEFAULT</li>
	<li>CREATE FUNCTION</li>
	<li>CREATE PROCEDURE</li>
	<li>CREATE RULE</li>
	<li>CREATE TABLE</li>
	<li>CREATE VIEW</li>
	<li>BACKUP DATABASE</li>
	<li>BACKUP LOG</li>
</ol>

<p>
<b>ВНИМАНИЕ!!!</b> Вы должны быть очень внимательны при раздаче таких прав, т.к. если у пользователя есть право на создание объекта, то при его создании он автоматически становится его владельцем и получает все права на использование!!! При предоставлении командных прав на создание, пользователь также получает права на изменение и удаление объектов!!!
</p>

<p>
Для раздачи таких прав используется также ключевое слово Grant.
</p>

<pre style="border-color:#FF0000">

<b>Grant</b> {ALL  | разрешение1, разрешение2... разрешениеN}

TO имя_учетной_записи1, имя_учетной_записи2... имя_учетной_записиN

</pre>

<p>
Аннулирование командных прав доступа:
</p>

<pre style="border-color:#FF0000">

<b>Revoke</b> {ALL [PRIVILEGES] | право1, право2... правоN }

FROM имя_учетной_записи1, имя_учетной_записи2... имя_учетной_записиN

</pre>

<p>
И в командных правах доступа также есть отказ:
</p>

<pre style="border-color:#FF0000">

DENY {ALL [PRIVILEGES] | разрешение1, разрешение2... разрешениеN}

TO имя_учетной_записи1, имя_учетной_записи2... имя_учетной_записиN

</pre>

<p>
Например, даем право пользователю test_user на создание представлений.
</p>

<pre>

Grant Create View To test_user

</pre>

<p>
Даем роли права на создание таблиц.
</p>

<pre>

Grant Create Table To test_role

</pre>

<p>
<b>ВНИМАНИЕ!!!</b> Право пользователю создавать таблицы не дает ему право на удаление других таблиц. Он может управлять только теми, которые сам создал.
</p>

<h3 align="center" style="color:#0E0076">Работа с правами доступа через Microsoft SQL Server Management Studio.</h3>

<p>
Для открытия окна с настройкой <b>командных</b> прав доступа к базе данных, нужно выбрать в контекстном меню к требуемой базе данных пункт Properties и перейти на вкладку Permissions.
</p>

<img src="img\pict17.jpg"></img>

<p>
Графический интерфейс позволяет устанавливать и снимать галочки, тем самым, раздавая, либо аннулируя право, указанное в имени заголовка столбца.
</p>


<p>
<b>Небольшой нюанс по раздаче прав.</b>
</p>

<p>
При рассмотрении темы представления, упоминалось о том, что при помощи представлений можно облегчить администрирование базы данных. Теперь об этом поподробнее.
</p>

<p>
Для того, чтобы определенному пользователю дать права на добавление информации в 3 из 10-ти ее полей есть 2 варианта:
</p>

<ol>
	<li>Написать запрос на предоставление такого права, используя ключевое слово Grant.</li>
	<li>Создать представление, работающее с этими полями и дать пользователю разрешение на добавление данных в представление.</li>
</ol>

<p>
При раздаче прав на использование хранимых процедур, вы должны понимать, что пользователю необходимо иметь право на Execute запросы, а при работе с функциями еще и право на Select запрос.
</p>

<h3 align="center" style="color:#0E0076">Цепочки подчинения.</h3>

<p>
Что же из себя представляет цепочка подчинения. Давайте рассмотрим такой пример: У нас есть определенная таблица Table1, владельцем которой выступает, к примеру, test_user. Он создает основанное на этой таблице представление MyView1 и дает право на выборку данных из представления пользователю test_user2. Test_user2 в свою очередь создает представление MyView2, основанное на данных представления MyView1, и дает право на выборку пользователю test_user3. Становится вопрос, а может ли test_user3 использовать данные, которые изначально хранятся в таблице Table1, ведь владелец этой таблицы не давал такого права. Более наглядно эта ситуация отображена на следующем рисунке:
</p>

<img src="img\pict20.jpg"></img>

<p>
Эта схема наглядно демонстрирует цепочки подчинения. Цепочки подчинения делятся на 2 вида:
</p>

<ol>
	<li>Однопользовательские цепочки подчинения.</li>
	<li>Разорванные цепочки подчинения.</li>
</ol>

<p>
<b>Однопользовательские цепочки подчинения.</b>
</p>

<p>Такая цепочка характерна, когда один пользователь владеет как созданным объектом, так и всеми объектами, данные из которых в него входят. При раздаче прав определенному пользователя на созданный объект, проверка права доступа будет производиться только один раз для созданного объекта.</p>

<p>
К примеру. Существует две таблицы, владельцем которых является пользователь test_user. Этот пользователь создает представление, основанное на данных двух этих таблиц. Называет его MyView1. Соответственно, он становится владельцем этого представления. После этого test_user создает представление MyView2, основанное на MyView1 и дает право на выборку пользователю test_user2. При чтении данных из MyView2 пользователем test_user2, проверка права доступа будет осуществлена только один раз, только для объекта MyView2, т.к. у всех объектов цепочки один владелец и, соответственно, если он дал право на вычитку на MyView2, то назначенное право распространяется на все объекты цепочки подчинения.
</p>

<img src="img\pict21.jpg"></img>

<p>
<b>Разорванные цепочки подчинения.</b>
</p>

<p>
Если объект, подчинен нескольким объектам, у которых разные пользователи, то проверка доступа будет производиться как для самого объекта, так и для всех объектов, участвующих в цепочке подчинения, у которых другой владелец.
</p>

<p>
Например, есть две таблицы Table1 и Table2. У обеих таблиц - владелец test_user. Этот пользователь создал представление MyView1, и дал право на выборку для test_user2. Test_user2, на основе MyView1, создает представление MyView2, и дает право на выборку из него для test_user3. При запросе на выборку данных пользователем test_user3, с начала будет производиться проверка на право выборки из MyView2, и, учитывая, что  владельцы объектов цепочки подчинения разные, будет производиться проверка на право выборки из MyView1. Учитывая, что у пользователя test_user3 нет прав на работу с MyView1, он не сможет просматривать содержимое и связанного с ним представления MyView2.
</p>

<img src="img\pict22.jpg"></img>

</Урок>